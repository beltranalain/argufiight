// This is your Prisma schema file
// Using PostgreSQL for production (Vercel Postgres)

generator client {
  provider      = "prisma-client-js"
  // For Vercel: use rhel-openssl-3.0.x
  // For local dev: native will be added by regenerate script if needed
  binaryTargets = ["rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User/Profile model for local authentication
model User {
  id           String  @id @default(uuid())
  email        String  @unique
  username     String  @unique
  passwordHash String  @map("password_hash")
  avatarUrl    String? @map("avatar_url")
  bio          String?

  // Stats
  eloRating    Int @default(1200) @map("elo_rating")
  debatesWon   Int @default(0) @map("debates_won")
  debatesLost  Int @default(0) @map("debates_lost")
  debatesTied  Int @default(0) @map("debates_tied")
  totalDebates Int @default(0) @map("total_debates")
  
  // Score System
  totalScore    Int @default(0) @map("total_score") // Sum of all scores from all debates
  totalMaxScore Int @default(0) @map("total_max_score") // Max possible (judges × 100 × debates)
  
  // Analytics
  totalWordCount      Int @default(0) @map("total_word_count") // Total words across all statements
  totalStatements     Int @default(0) @map("total_statements") // Total number of statements submitted
  averageWordCount    Float @default(0) @map("average_word_count") // Average words per statement
  averageRounds       Float @default(0) @map("average_rounds") // Average rounds per debate

  // Permissions
  isAdmin  Boolean @default(false) @map("is_admin")
  isBanned Boolean @default(false) @map("is_banned")

  // Employee fields (only for employees)
  employeeRole String? @map("employee_role") // e.g., "Admin", "Moderator", "Support"
  accessLevel  String? @map("access_level") // e.g., "full", "moderation", "support"

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Moderation
  strikes      Int       @default(0)
  bannedUntil  DateTime? @map("banned_until")
  banReason    String?   @map("ban_reason")
  rankedBanned Boolean   @default(false) @map("ranked_banned")

  // Relations
  sessions          Session[]
  challengerDebates Debate[]        @relation("Challenger")
  opponentDebates   Debate[]        @relation("Opponent")
  statements        Statement[]
  notifications     Notification[]
  chatMessages      ChatMessage[]
  reports           Report[]
  predictions       Prediction[]
  apiUsage          ApiUsage[]
  debateLikes       DebateLike[]
  debateSaves       DebateSave[]
  debateShares      DebateShare[]
  debateComments    DebateComment[]
  following         Follow[]        @relation("Follower")
  followers         Follow[]        @relation("Following")
  createdModels     ModelVersion[]  @relation("ModelCreator")

  // Tournament relations
  createdTournaments       Tournament[]            @relation("TournamentCreator")
  tournamentParticipations TournamentParticipant[] @relation("TournamentParticipant")
  tournamentSubscription   TournamentSubscription?
  
  // Appeal limits
  appealLimit              AppealLimit?
  appealSubscriptions      AppealSubscription[]

  @@index([email])
  @@index([username])
  @@index([eloRating])

  @@map("users")
}

// ============================================
// APPEAL LIMITS & SUBSCRIPTIONS
// ============================================

model AppealLimit {
  id              String   @id @default(uuid())
  userId          String   @unique @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  monthlyLimit    Int      @default(4) @map("monthly_limit")
  currentCount    Int      @default(0) @map("current_count")
  resetDate       DateTime @default(now()) @map("reset_date")
  subscriptionTier String? @map("subscription_tier") // FREE, PREMIUM, PRO
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("appeal_limits")
}

model AppealSubscription {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  planName        String   @map("plan_name") // e.g., "Premium Appeals"
  appealsIncluded Int      @map("appeals_included")
  price           Decimal  @db.Decimal(10, 2)
  status          String   // ACTIVE, CANCELLED, EXPIRED
  startDate       DateTime @default(now()) @map("start_date")
  endDate         DateTime? @map("end_date")
  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([status])
  @@map("appeal_subscriptions")
}

// ============================================
// SUBSCRIPTION PLANS
// ============================================

model SubscriptionPlan {
  id                String   @id @default(uuid())
  name              String   // "Free", "Premium", "Pro"
  description       String?  @db.Text
  price             Decimal  @db.Decimal(10, 2)
  billingCycle      String   // MONTHLY, YEARLY
  features          String   @db.Text // JSON array of features
  appealLimit       Int?     @map("appeal_limit")
  debateLimit       Int?     @map("debate_limit")
  prioritySupport   Boolean  @default(false) @map("priority_support")
  customBadge       String?  @map("custom_badge")
  stripePriceId     String?  @unique @map("stripe_price_id")
  stripeProductId   String?  @map("stripe_product_id")
  isActive          Boolean  @default(false) @map("is_active") // Don't activate yet
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@index([isActive])
  @@index([billingCycle])
  @@map("subscription_plans")
}

// ============================================
// ADVERTISEMENTS
// ============================================

model Advertisement {
  id            String   @id @default(uuid())
  title         String
  type          String   // BANNER, SPONSORED_DEBATE, IN_FEED
  creativeUrl   String   @map("creative_url")
  targetUrl     String   @map("target_url")
  status        String   @default("DRAFT") // DRAFT, ACTIVE, PAUSED
  startDate     DateTime? @map("start_date")
  endDate       DateTime? @map("end_date")
  impressions   Int      @default(0)
  clicks        Int      @default(0)
  category      String?  // Target specific category
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([status])
  @@index([type])
  @@index([category])
  @@map("advertisements")
}

// ============================================
// SOCIAL MEDIA POSTS
// ============================================

model SocialMediaPost {
  id            String   @id @default(uuid())
  debateId      String   @map("debate_id")
  debate        Debate   @relation(fields: [debateId], references: [id], onDelete: Cascade)
  platform      String   // INSTAGRAM, LINKEDIN, TWITTER
  content       String   @db.Text
  imagePrompt   String?  @db.Text @map("image_prompt")
  hashtags      String?
  status        String   @default("DRAFT") // DRAFT, APPROVED, PUBLISHED
  scheduledAt   DateTime? @map("scheduled_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([debateId])
  @@index([platform])
  @@index([status])
  @@map("social_media_posts")
}

// Session model for authentication
model Session {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@map("sessions")
}

// ============================================
// DEBATES
// ============================================

model Debate {
  id          String         @id @default(uuid())
  topic       String
  description String?
  category    DebateCategory

  // Participants
  challengerId String @map("challenger_id")
  challenger   User   @relation("Challenger", fields: [challengerId], references: [id], onDelete: Cascade)

  opponentId String? @map("opponent_id")
  opponent   User?   @relation("Opponent", fields: [opponentId], references: [id], onDelete: SetNull)

  // Direct Challenge System
  challengeType  String  @default("OPEN") @map("challenge_type") // OPEN, DIRECT, GROUP
  invitedUserIds String? @map("invited_user_ids") // JSON array of user IDs for direct/group challenges
  invitedBy      String? @map("invited_by") // User ID who sent the direct challenge

  // Positions
  challengerPosition DebatePosition @map("challenger_position")
  opponentPosition   DebatePosition @map("opponent_position")

  // Configuration
  totalRounds   Int     @default(5) @map("total_rounds")
  currentRound  Int     @default(1) @map("current_round")
  roundDuration Int     @default(86400000) @map("round_duration") // milliseconds (24h default)
  speedMode     Boolean @default(false) @map("speed_mode")

  // Status
  status DebateStatus @default(WAITING)

  // Verdict
  winnerId       String?   @map("winner_id")
  verdictReached Boolean   @default(false) @map("verdict_reached")
  verdictDate    DateTime? @map("verdict_date")

  // Appeal System
  appealedAt            DateTime?     @map("appealed_at")
  appealStatus          AppealStatus? @map("appeal_status")
  appealCount           Int           @default(0) @map("appeal_count")
  appealedBy            String?       @map("appealed_by") // User ID who appealed
  originalWinnerId      String?       @map("original_winner_id") // Store original winner before appeal
  appealReason          String?       @map("appeal_reason") // User's explanation for why they're appealing
  appealedStatements    String?       @map("appealed_statements") // JSON array of statement IDs being appealed
  appealRejectionReason String?       @map("appeal_rejection_reason") // AI-generated reason when appeal doesn't change verdict

  // Rematch System
  rematchRequestedBy String?        @map("rematch_requested_by") // User ID who requested rematch
  rematchRequestedAt DateTime?      @map("rematch_requested_at")
  rematchStatus      RematchStatus? @map("rematch_status")
  originalDebateId   String?        @map("original_debate_id") // Reference to the original debate if this is a rematch
  rematchDebateId    String?        @map("rematch_debate_id") // Reference to the rematch debate if one was created

  // Metadata
  spectatorCount Int     @default(0) @map("spectator_count")
  viewCount      Int     @default(0) @map("view_count")
  featured       Boolean @default(false)
  allowCopyPaste Boolean @default(true) @map("allow_copy_paste") // Allow copy-paste in arguments
  
  // Privacy
  isPrivate      Boolean @default(false) @map("is_private") // Private debates require share token
  shareToken     String? @unique @map("share_token") // Unique token for sharing private debates

  // Relations
  images DebateImage[]

  // ELO changes
  challengerEloChange Int? @map("challenger_elo_change")
  opponentEloChange   Int? @map("opponent_elo_change")

  // Timestamps
  startedAt DateTime? @map("started_at")
  endedAt   DateTime? @map("ended_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  // Round deadlines
  roundDeadline DateTime? @map("round_deadline")

  // Relations
  statements        Statement[]
  verdicts          Verdict[]
  chatMessages      ChatMessage[]
  notifications     Notification[]
  reports           Report[]
  predictions       Prediction[]
  apiUsage          ApiUsage[]
  likes             DebateLike[]
  saves             DebateSave[]
  shares            DebateShare[]
  comments          DebateComment[]
  appealPredictions AppealPrediction[]
  tags              DebateTag[]
  tournamentMatch   TournamentMatch?   @relation("TournamentDebate")
  socialMediaPosts  SocialMediaPost[]

  @@index([status])
  @@index([category])
  @@index([createdAt])
  @@index([challengerId])
  @@index([opponentId])
  @@map("debates")
}

enum DebateCategory {
  SPORTS
  POLITICS
  TECH
  ENTERTAINMENT
  SCIENCE
  MUSIC
  OTHER
}

enum DebatePosition {
  FOR
  AGAINST
}

enum DebateStatus {
  WAITING // Waiting for opponent
  ACTIVE // Debate in progress
  COMPLETED // Debate finished, awaiting verdict
  VERDICT_READY // AI judges decided
  APPEALED // Verdict appealed, awaiting re-verdict
  CANCELLED // Cancelled before completion
}

enum AppealStatus {
  PENDING // Appeal submitted, awaiting new verdict
  PROCESSING // New verdict being generated
  RESOLVED // Appeal resolved with new verdict
  DENIED // Appeal denied (if we add validation)
}

enum RematchStatus {
  PENDING // Rematch requested, awaiting response
  ACCEPTED // Rematch accepted, debate created
  DECLINED // Rematch declined
}

// ============================================
// STATEMENTS (Arguments)
// ============================================

model Statement {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  authorId String @map("author_id")
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  round   Int
  content String

  // Moderation
  flagged       Boolean   @default(false)
  flaggedReason String?   @map("flagged_reason")
  moderatedAt   DateTime? @map("moderated_at")

  // AI Moderation
  aiModerated   Boolean   @default(false) @map("ai_moderated")
  aiAction      String?   @map("ai_action") // APPROVE, REMOVE, ESCALATE
  aiConfidence  Int?      @map("ai_confidence") // 0-100
  aiReasoning   String?   @map("ai_reasoning")
  aiSeverity    String?   @map("ai_severity") // LOW, MEDIUM, HIGH, CRITICAL
  aiModeratedAt DateTime? @map("ai_moderated_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([debateId, authorId, round])
  @@index([debateId])
  @@index([authorId])
  @@map("statements")
}

// ============================================
// DEBATE IMAGES
// ============================================

model DebateImage {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  url     String // Image URL or path
  alt     String? // Alt text for accessibility
  caption String? // Optional caption/description
  order   Int     @default(0) // Display order

  // Metadata
  width    Int?
  height   Int?
  fileSize Int?    @map("file_size")
  mimeType String? @map("mime_type")

  // Upload info
  uploadedBy String?  @map("uploaded_by") // User ID
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([debateId])
  @@index([order])
  @@map("debate_images")
}

// ============================================
// AI JUDGES
// ============================================

model Judge {
  id          String @id @default(uuid())
  name        String @unique
  personality String
  emoji       String
  description String

  // System prompt for this judge
  systemPrompt String @map("system_prompt") // Store as text in SQLite

  // Stats
  debatesJudged Int @default(0) @map("debates_judged")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  verdicts    Verdict[]
  tournaments Tournament[]

  @@map("judges")
}

// ============================================
// VERDICTS
// ============================================

model Verdict {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  judgeId String @map("judge_id")
  judge   Judge  @relation(fields: [judgeId], references: [id], onDelete: Cascade)

  // Decision
  winnerId  String?         @map("winner_id")
  decision  VerdictDecision
  reasoning String

  // Scores
  challengerScore Int? @map("challenger_score") // 0-100
  opponentScore   Int? @map("opponent_score") // 0-100

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, judgeId])
  @@index([debateId])
  @@map("verdicts")
}

enum VerdictDecision {
  CHALLENGER_WINS
  OPPONENT_WINS
  TIE
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id     String @id @default(uuid())
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String

  // Optional debate reference
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: Cascade)

  read   Boolean   @default(false)
  readAt DateTime? @map("read_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([read])
  @@map("notifications")
}

enum NotificationType {
  DEBATE_TURN // Your turn to argue
  DEBATE_ACCEPTED // Your challenge was accepted
  ROUND_ENDING // Round ending soon
  VERDICT_READY // AI judges decided
  DEBATE_WON // You won
  DEBATE_LOST // You lost
  DEBATE_TIED // Debate tied
  NEW_CHALLENGE // Someone challenged you
  OPPONENT_SUBMITTED // Opponent submitted argument
  DEBATE_INVITATION // Direct challenge invitation
  DEBATE_GROUP_INVITATION // Group challenge invitation
  REMATCH_REQUESTED // Someone requested a rematch
  REMATCH_ACCEPTED // Rematch was accepted
  REMATCH_DECLINED // Rematch was declined
}

// ============================================
// CHAT
// ============================================

model ChatMessage {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  authorId String @map("author_id")
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  content String

  // Moderation
  deleted   Boolean   @default(false)
  deletedAt DateTime? @map("deleted_at")
  deletedBy String?   @map("deleted_by")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([debateId])
  @@index([authorId])
  @@index([createdAt])
  @@map("chat_messages")
}

// ============================================
// MODERATION
// ============================================

model Report {
  id String @id @default(uuid())

  // What's being reported
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Who reported
  reporterId String @map("reporter_id")
  reporter   User   @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  // Report details
  reason      String
  description String?

  // Status
  status     ReportStatus @default(PENDING)
  reviewedBy String?      @map("reviewed_by")
  reviewedAt DateTime?    @map("reviewed_at")
  resolution String?

  // AI Moderation
  aiModerated   Boolean   @default(false) @map("ai_moderated")
  aiAction      String?   @map("ai_action") // APPROVE, REMOVE, ESCALATE
  aiConfidence  Int?      @map("ai_confidence") // 0-100
  aiReasoning   String?   @map("ai_reasoning")
  aiSeverity    String?   @map("ai_severity") // LOW, MEDIUM, HIGH, CRITICAL
  aiModeratedAt DateTime? @map("ai_moderated_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([status])
  @@index([aiModerated])
  @@map("reports")
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

// ============================================
// PREDICTIONS (Spectator betting)
// ============================================

model Prediction {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Prediction
  predictedWinnerId String @map("predicted_winner_id")
  confidence        Int // 1-5 stars

  // Result
  correct Boolean?
  points  Int? // Points earned/lost

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([userId])
  @@map("predictions")
}

// ============================================
// ADMIN SETTINGS (API Keys)
// ============================================

model AdminSetting {
  id    String @id @default(uuid())
  key   String @unique
  value String

  // Encryption flag
  encrypted Boolean @default(false)

  // Metadata
  description String?
  category    String?

  updatedBy String?  @map("updated_by")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([category])
  @@map("admin_settings")
}

// Waiting list for users when user limit is reached
model WaitingList {
  id           String    @id @default(uuid())
  email        String    @unique
  username     String    @unique
  passwordHash String    @map("password_hash") // Store hashed password for when they're approved
  position     Int // Position in waiting list (1 = first, 2 = second, etc.)
  notified     Boolean   @default(false) @map("notified") // Whether they've been notified
  approved     Boolean   @default(false) @map("approved") // Whether they've been approved to join
  approvedAt   DateTime? @map("approved_at")
  approvedBy   String?   @map("approved_by") // Admin who approved them

  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([email])
  @@index([position])
  @@index([approved])
  @@map("waiting_list")
}

// ============================================
// API USAGE TRACKING
// ============================================

model ApiUsage {
  id String @id @default(uuid())

  // API Details
  provider String // e.g., "deepseek", "openai", "resend"
  endpoint String // e.g., "chat/completions"
  model    String? // e.g., "deepseek-chat"

  // Request/Response Metrics
  promptTokens     Int? @map("prompt_tokens")
  completionTokens Int? @map("completion_tokens")
  totalTokens      Int? @map("total_tokens")

  // Cost Calculation
  cost            Float  @default(0) // Cost in USD
  costPer1kTokens Float? @map("cost_per_1k_tokens") // Cost per 1k tokens

  // Context
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: SetNull)
  userId   String? @map("user_id")
  user     User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Status
  success      Boolean @default(true)
  errorMessage String? @map("error_message")

  // Metadata
  responseTime Int?    @map("response_time") // in milliseconds
  metadata     String? // JSON string for additional data

  createdAt DateTime @default(now()) @map("created_at")

  @@index([provider])
  @@index([debateId])
  @@index([userId])
  @@index([createdAt])
  @@map("api_usage")
}

// ============================================
// SEED DEBATES (AI-generated sample debates)
// ============================================

model SeedDebate {
  id             String         @id @default(uuid())
  topic          String
  category       DebateCategory
  challengerName String         @map("challenger_name")
  opponentName   String         @map("opponent_name")

  // Pre-generated content (stored as JSON strings in SQLite)
  statements  String // JSON string
  verdictData String @map("verdict_data") // JSON string

  featured Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")

  @@index([category])
  @@map("seed_debates")
}

// ============================================
// DEBATE INTERACTIONS & SOCIAL FEATURES
// ============================================

// Like a debate
model DebateLike {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@map("debate_likes")
}

// Save/bookmark a debate
model DebateSave {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@map("debate_saves")
}

// Share a debate
model DebateShare {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Share method (optional tracking)
  method String? // e.g., "twitter", "facebook", "copy_link"

  createdAt DateTime @default(now()) @map("created_at")

  @@index([debateId])
  @@index([userId])
  @@map("debate_shares")
}

// Comment on a debate
model DebateComment {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  content String

  // Optional: Reply to another comment
  parentId String?         @map("parent_id")
  parent   DebateComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  DebateComment[] @relation("CommentReplies")

  // Moderation
  deleted   Boolean   @default(false)
  deletedAt DateTime? @map("deleted_at")
  deletedBy String?   @map("deleted_by")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([debateId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("debate_comments")
}

// Follow another user
model Follow {
  id          String @id @default(uuid())
  followerId  String @map("follower_id")
  follower    User   @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String @map("following_id")
  following   User   @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// ============================================
// TAGS
// ============================================

model Tag {
  id         String   @id @default(uuid())
  name       String   @unique
  color      String   @default("#00aaff")
  usageCount Int      @default(0) @map("usage_count")
  createdAt  DateTime @default(now()) @map("created_at")

  debateTags DebateTag[]

  @@index([name])
  @@index([usageCount])
  @@map("tags")
}

model DebateTag {
  id        String   @id @default(uuid())
  debateId  String   @map("debate_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  debate Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([debateId, tagId])
  @@index([debateId])
  @@index([tagId])
  @@map("debate_tags")
}

// ============================================
// LLM MODEL MANAGEMENT
// ============================================

// Model versions for tracking different LLM models
model ModelVersion {
  id          String  @id @default(uuid())
  name        String // e.g., "Appeal Predictor v1.0"
  version     String // e.g., "1.0.0"
  description String?
  modelType   String  @map("model_type") // e.g., "appeal_predictor", "verdict_judge"

  // Configuration
  config String? // JSON string for model configuration (hyperparameters, etc.)

  // Status
  isActive  Boolean @default(false) @map("is_active")
  isDefault Boolean @default(false) @map("is_default")

  // Metadata
  createdBy String?  @map("created_by")
  creator   User?    @relation("ModelCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  metrics           ModelMetric[]
  abTestsA          ABTest[]           @relation("ABTestModelA")
  abTestsB          ABTest[]           @relation("ABTestModelB")
  appealPredictions AppealPrediction[]

  @@unique([name, version])
  @@index([modelType])
  @@index([isActive])
  @@map("model_versions")
}

// ============================================
// CATEGORIES
// ============================================

model Category {
  id          String  @id @default(uuid())
  name        String  @unique // e.g., "SPORTS", "TECH"
  label       String // Display name e.g., "Sports", "Tech"
  description String?
  color       String? // Hex color for UI
  icon        String? // Icon/emoji
  isActive    Boolean @default(true) @map("is_active")
  sortOrder   Int     @default(0) @map("sort_order")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("categories")
}

// Performance metrics for model versions
model ModelMetric {
  id             String       @id @default(uuid())
  modelVersionId String       @map("model_version_id")
  modelVersion   ModelVersion @relation(fields: [modelVersionId], references: [id], onDelete: Cascade)

  // Metrics
  metricType  String @map("metric_type") // e.g., "accuracy", "precision", "recall", "f1_score"
  metricValue Float  @map("metric_value")

  // Context
  dataset String? // e.g., "training", "validation", "test"
  period  String? // e.g., "daily", "weekly", "monthly"

  // Metadata
  recordedAt DateTime @default(now()) @map("recorded_at")
  notes      String?

  @@index([modelVersionId])
  @@index([metricType])
  @@index([recordedAt])
  @@map("model_metrics")
}

// A/B Testing for model comparison
model ABTest {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Models being tested
  modelVersionAId String       @map("model_version_a_id")
  modelVersionA   ModelVersion @relation("ABTestModelA", fields: [modelVersionAId], references: [id], onDelete: Cascade)

  modelVersionBId String       @map("model_version_b_id")
  modelVersionB   ModelVersion @relation("ABTestModelB", fields: [modelVersionBId], references: [id], onDelete: Cascade)

  // Configuration
  trafficSplit Int       @default(50) @map("traffic_split") // Percentage for model A (0-100)
  startDate    DateTime  @map("start_date")
  endDate      DateTime? @map("end_date")

  // Status
  status   String  @default("draft") // draft, active, completed, cancelled
  isActive Boolean @default(false) @map("is_active")

  // Results
  modelAScore Float?  @map("model_a_score")
  modelBScore Float?  @map("model_b_score")
  winner      String? // "A", "B", or "tie"

  // Metadata
  createdBy String?  @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([status])
  @@index([isActive])
  @@index([startDate])
  @@map("ab_tests")
}

// Appeal success prediction tracking
model AppealPrediction {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Model used
  modelVersionId String?       @map("model_version_id")
  modelVersion   ModelVersion? @relation(fields: [modelVersionId], references: [id], onDelete: SetNull)

  // Prediction
  predictedSuccess Boolean @map("predicted_success") // Will the appeal succeed?
  confidence       Float // 0.0 to 1.0
  reasoning        String? // Model's reasoning

  // Actual result
  actualSuccess Boolean? @map("actual_success") // Did appeal actually succeed?

  // Metadata
  predictedAt DateTime  @default(now()) @map("predicted_at")
  resolvedAt  DateTime? @map("resolved_at")

  @@unique([debateId])
  @@index([modelVersionId])
  @@index([predictedSuccess])
  @@index([actualSuccess])
  @@map("appeal_predictions")
}

// ============================================
// HOMEPAGE CONTENT MANAGEMENT
// ============================================

// Homepage sections (Hero, Features, How It Works, etc.)
model HomepageSection {
  id        String  @id @default(uuid())
  key       String  @unique // e.g., "hero", "features", "how-it-works"
  title     String? // Section title
  content   String? // Rich text content (HTML or markdown)
  order     Int     @default(0) // Display order
  isVisible Boolean @default(true) @map("is_visible")

  // SEO
  metaTitle       String? @map("meta_title")
  metaDescription String? @map("meta_description")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  images  HomepageImage[]
  buttons HomepageButton[]

  @@index([key])
  @@index([order])
  @@index([isVisible])
  @@map("homepage_sections")
}

// Images for homepage sections
model HomepageImage {
  id        String          @id @default(uuid())
  sectionId String          @map("section_id")
  section   HomepageSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  url     String // Image URL or path
  alt     String? // Alt text
  caption String? // Image caption
  linkUrl String? @map("link_url") // Optional link URL for clickable images (e.g., App Store/Google Play links)
  order   Int     @default(0) // Display order within section

  // Metadata
  width    Int?
  height   Int?
  fileSize Int?    @map("file_size")
  mimeType String? @map("mime_type")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([sectionId])
  @@index([order])
  @@map("homepage_images")
}

// Buttons/CTAs for homepage sections
model HomepageButton {
  id        String          @id @default(uuid())
  sectionId String          @map("section_id")
  section   HomepageSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  text    String // Button text
  url     String? // Link URL (e.g., "/signup", "/login")
  variant String  @default("primary") // Button style
  order   Int     @default(0) // Display order

  isVisible Boolean @default(true) @map("is_visible")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([sectionId])
  @@index([order])
  @@map("homepage_buttons")
}

// Media library for all uploaded images
model MediaLibrary {
  id       String  @id @default(uuid())
  url      String  @unique // File path or URL
  filename String // Original filename
  alt      String? // Alt text
  caption  String? // Caption

  // File metadata
  width    Int?
  height   Int?
  fileSize Int    @map("file_size")
  mimeType String @map("mime_type")

  // Usage tracking
  usedIn String? @map("used_in") // e.g., "homepage:hero", "homepage:features"

  // Upload metadata
  uploadedBy String?  @map("uploaded_by") // User ID
  uploadedAt DateTime @default(now()) @map("uploaded_at")

  @@index([usedIn])
  @@index([uploadedBy])
  @@index([uploadedAt])
  @@map("media_library")
}

// Legal pages (Terms of Service, Privacy Policy, etc.)
model LegalPage {
  id        String  @id @default(uuid())
  slug      String  @unique // e.g., "terms", "privacy"
  title     String // Page title
  content   String // Rich text content (HTML)
  isVisible Boolean @default(true) @map("is_visible")

  // SEO
  metaTitle       String? @map("meta_title")
  metaDescription String? @map("meta_description")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([slug])
  @@index([isVisible])
  @@map("legal_pages")
}

// Social media links for footer
model SocialMediaLink {
  id        String  @id @default(uuid())
  platform  String  @unique // FACEBOOK, TWITTER, INSTAGRAM, LINKEDIN, YOUTUBE, TIKTOK
  url       String
  order     Int     @default(0)
  isActive  Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([platform])
  @@index([isActive])
  @@index([order])
  @@map("social_media_links")
}

// ============================================
// TOURNAMENTS
// ============================================

enum TournamentStatus {
  UPCOMING
  REGISTRATION_OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ReseedMethod {
  ELO_BASED
  TOURNAMENT_WINS
  RANDOM
}

enum ParticipantStatus {
  REGISTERED
  ACTIVE
  ELIMINATED
  DISQUALIFIED
}

enum RoundStatus {
  UPCOMING
  IN_PROGRESS
  COMPLETED
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  FORFEITED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}

model Tournament {
  id          String  @id @default(uuid())
  name        String
  description String?
  creatorId   String  @map("creator_id")
  creator     User    @relation("TournamentCreator", fields: [creatorId], references: [id])

  // Settings
  maxParticipants Int              @default(16) @map("max_participants")
  currentRound    Int              @default(1) @map("current_round")
  totalRounds     Int              @map("total_rounds")
  status          TournamentStatus @default(UPCOMING)

  // Requirements
  minElo  Int?    @map("min_elo")
  judgeId String? @map("judge_id")
  judge   Judge?  @relation(fields: [judgeId], references: [id])

  // Timing
  startDate     DateTime  @map("start_date")
  endDate       DateTime? @map("end_date")
  roundDuration Int       @map("round_duration") // Hours per round

  // Reseeding
  reseedAfterRound Boolean      @default(true) @map("reseed_after_round")
  reseedMethod     ReseedMethod @default(ELO_BASED) @map("reseed_method")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  participants TournamentParticipant[]
  matches      TournamentMatch[]
  rounds       TournamentRound[]

  @@index([creatorId])
  @@index([status])
  @@map("tournaments")
}

model TournamentParticipant {
  id           String     @id @default(uuid())
  tournamentId String     @map("tournament_id")
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  userId       String     @map("user_id")
  user         User       @relation("TournamentParticipant", fields: [userId], references: [id])

  // Tournament-specific stats
  seed        Int?
  currentSeed Int? @map("current_seed")
  wins        Int  @default(0)
  losses      Int  @default(0)
  eloAtStart  Int  @map("elo_at_start")

  // Status
  status       ParticipantStatus @default(REGISTERED)
  eliminatedAt DateTime?         @map("eliminated_at")

  registeredAt DateTime @default(now()) @map("registered_at")

  matches1   TournamentMatch[] @relation("Participant1")
  matches2   TournamentMatch[] @relation("Participant2")
  wonMatches TournamentMatch[] @relation("MatchWinner")

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@index([userId])
  @@map("tournament_participants")
}

model TournamentRound {
  id           String     @id @default(uuid())
  tournamentId String     @map("tournament_id")
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  roundNumber Int         @map("round_number")
  status      RoundStatus @default(UPCOMING)
  startDate   DateTime?   @map("start_date")
  endDate     DateTime?   @map("end_date")

  matches TournamentMatch[]

  @@unique([tournamentId, roundNumber])
  @@index([tournamentId])
  @@map("tournament_rounds")
}

model TournamentMatch {
  id           String          @id @default(uuid())
  tournamentId String          @map("tournament_id")
  tournament   Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  roundId      String          @map("round_id")
  round        TournamentRound @relation(fields: [roundId], references: [id])

  participant1Id String                @map("participant1_id")
  participant1   TournamentParticipant @relation("Participant1", fields: [participant1Id], references: [id])
  participant2Id String                @map("participant2_id")
  participant2   TournamentParticipant @relation("Participant2", fields: [participant2Id], references: [id])

  // Link to actual debate
  debateId String? @unique @map("debate_id")
  debate   Debate? @relation("TournamentDebate", fields: [debateId], references: [id])

  // Match result
  winnerId String?                @map("winner_id")
  winner   TournamentParticipant? @relation("MatchWinner", fields: [winnerId], references: [id])
  status   MatchStatus            @default(SCHEDULED)

  scheduledAt DateTime? @map("scheduled_at")
  completedAt DateTime? @map("completed_at")

  @@index([tournamentId])
  @@index([roundId])
  @@index([debateId])
  @@map("tournament_matches")
}

model TournamentSubscription {
  id     String @id @default(uuid())
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id])

  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  stripeCustomerId     String? @map("stripe_customer_id")

  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime           @map("current_period_start")
  currentPeriodEnd   DateTime           @map("current_period_end")

  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  cancelledAt DateTime? @map("cancelled_at")

  @@index([userId])
  @@index([status])
  @@map("tournament_subscriptions")
}
