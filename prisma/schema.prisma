// This is your Prisma schema file
// Using PostgreSQL for production (Vercel Postgres)

generator client {
  provider      = "prisma-client-js"
  // For Vercel: use rhel-openssl-3.0.x
  // For local dev: native will be added by regenerate script if needed
  binaryTargets = ["rhel-openssl-3.0.x", "native"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User/Profile model for local authentication
model User {
  id           String  @id @default(uuid())
  email        String  @unique
  username     String  @unique
  passwordHash String? @map("password_hash") // Optional for OAuth users
  avatarUrl    String? @map("avatar_url")
  bio          String?

  // Stats
  eloRating    Int @default(1200) @map("elo_rating")
  debatesWon   Int @default(0) @map("debates_won")
  debatesLost  Int @default(0) @map("debates_lost")
  debatesTied  Int @default(0) @map("debates_tied")
  totalDebates Int @default(0) @map("total_debates")

  // Belt stats
  totalBeltWins     Int @default(0) @map("total_belt_wins")
  totalBeltDefenses Int @default(0) @map("total_belt_defenses")
  longestBeltHeld   Int @default(0) @map("longest_belt_held") // Days
  currentBeltsCount Int @default(0) @map("current_belts_count") // Cached count

  // Coin System
  coins Int @default(0) // User's coin balance
  
  // Free Belt Challenges (weekly reset)
  freeBeltChallengesAvailable Int      @default(1) @map("free_belt_challenges_available") // Number of free challenges available
  lastFreeChallengeReset      DateTime? @map("last_free_challenge_reset") // When free challenge was last reset

  // Score System
  totalScore    Int @default(0) @map("total_score") // Sum of all scores from all debates
  totalMaxScore Int @default(0) @map("total_max_score") // Max possible (judges × 100 × debates)

  // Analytics
  totalWordCount   Int   @default(0) @map("total_word_count") // Total words across all statements
  totalStatements  Int   @default(0) @map("total_statements") // Total number of statements submitted
  averageWordCount Float @default(0) @map("average_word_count") // Average words per statement
  averageRounds    Float @default(0) @map("average_rounds") // Average rounds per debate

  // Permissions
  isAdmin  Boolean @default(false) @map("is_admin")
  isBanned Boolean @default(false) @map("is_banned")

  // Employee fields (only for employees)
  employeeRole String? @map("employee_role") // e.g., "Admin", "Moderator", "Support"
  accessLevel  String? @map("access_level") // e.g., "full", "moderation", "support"

  // Creator marketplace fields
  isCreator     Boolean        @default(false) @map("is_creator")
  creatorStatus CreatorStatus?
  creatorSince  DateTime?      @map("creator_since")

  // Ad slot availability
  profileBannerAvailable Boolean @default(true) @map("profile_banner_available")
  postDebateAvailable    Boolean @default(true) @map("post_debate_available")
  debateWidgetAvailable  Boolean @default(true) @map("debate_widget_available")

  // Pricing (creator sets their own rates)
  profileBannerPrice Decimal? @map("profile_banner_price") @db.Decimal(10, 2)
  postDebatePrice    Decimal? @map("post_debate_price") @db.Decimal(10, 2)
  debateWidgetPrice  Decimal? @map("debate_widget_price") @db.Decimal(10, 2)

  // Stats for advertisers (calculated monthly)
  avgMonthlyViews Int @default(0) @map("avg_monthly_views")
  avgDebateViews  Int @default(0) @map("avg_debate_views")
  followerCount   Int @default(0) @map("follower_count")
  profileVisits   Int @default(0) @map("profile_visits")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Moderation
  strikes      Int       @default(0)
  bannedUntil  DateTime? @map("banned_until")
  banReason    String?   @map("ban_reason")
  rankedBanned Boolean   @default(false) @map("ranked_banned")

  // AI User fields
  isAI            Boolean @default(false) @map("is_ai")
  aiPersonality   String? @map("ai_personality") // BALANCED, SMART, AGGRESSIVE, CALM, WITTY, ANALYTICAL
  aiResponseDelay Int?    @map("ai_response_delay") // milliseconds (e.g., 600000 for 10 min, 3600000 for 1 hour, 86400000 for 1 day)
  aiPaused        Boolean @default(false) @map("ai_paused")

  // Google OAuth fields (for advertisers and employees only)
  googleId          String? @unique @map("google_id")
  googleEmail       String? @map("google_email")
  googlePicture     String? @map("google_picture")
  googleAuthEnabled Boolean @default(false) @map("google_auth_enabled")

  // Google Authenticator 2FA (for employees and advertisers)
  totpSecret      String? @map("totp_secret") // Secret key for TOTP
  totpEnabled     Boolean @default(false) @map("totp_enabled") // Whether 2FA is enabled
  totpBackupCodes String? @map("totp_backup_codes") // JSON array of backup codes

  // Relations
  sessions          Session[]
  challengerDebates Debate[]        @relation("Challenger")
  opponentDebates   Debate[]        @relation("Opponent")
  statements        Statement[]
  notifications     Notification[]
  chatMessages      ChatMessage[]
  reports           Report[]
  predictions       Prediction[]
  apiUsage          ApiUsage[]
  debateLikes       DebateLike[]
  debateSaves       DebateSave[]
  debateShares      DebateShare[]
  debateComments    DebateComment[]
  following         Follow[]        @relation("Follower")
  followers         Follow[]        @relation("Following")
  createdModels     ModelVersion[]  @relation("ModelCreator")

  // Tournament relations
  createdTournaments       Tournament[]            @relation("TournamentCreator")
  tournamentParticipations TournamentParticipant[] @relation("TournamentParticipant")
  tournamentSubscription   TournamentSubscription?

  // Multi-participant debate relations
  debateParticipations DebateParticipant[] @relation("DebateParticipants")

  // Belt relations
  beltsHeld              Belt[]          @relation("BeltHolder")
  beltChallengesSent     BeltChallenge[] @relation("BeltChallenger")
  beltChallengesReceived BeltChallenge[] @relation("BeltHolderChallenge")
  beltHistoryFrom        BeltHistory[]   @relation("BeltHistoryFrom")
  beltHistoryTo          BeltHistory[]   @relation("BeltHistoryTo")

  // Coin transactions
  coinTransactions CoinTransaction[] @relation("CoinTransactionUser")

  // Appeal limits
  appealLimit         AppealLimit?
  appealSubscriptions AppealSubscription[]

  // Subscription
  subscription UserSubscription?

  // Usage Tracking
  usageTracking UsageTracking[]

  // Support tickets
  supportTickets       SupportTicket[]
  supportTicketReplies SupportTicketReply[]
  assignedTickets      SupportTicket[]      @relation("AssignedTickets")

  // FCM Push Notification Tokens
  fcmTokens   FCMToken[]   @relation("FCMTokens")
  cardMembers CardMember[] @relation("CardMembers")

  // Direct messages
  sentMessages         DirectMessage[] @relation("MessageSender")
  receivedMessages     DirectMessage[] @relation("MessageReceiver")
  conversationsAsUser1 Conversation[]  @relation("User1")
  conversationsAsUser2 Conversation[]  @relation("User2")

  // Creator marketplace relations
  offersReceived  Offer[]         @relation("OffersReceived")
  activeContracts AdContract[]    @relation("CreatorContracts")
  creatorTaxInfo  CreatorTaxInfo?

  // Blog relations
  blogPosts BlogPost[] @relation("BlogPostAuthor")

  @@index([email])
  @@index([username])
  @@index([eloRating])
  @@map("users")
}

// ============================================
// APPEAL LIMITS & SUBSCRIPTIONS
// ============================================

model AppealLimit {
  id           String   @id @default(uuid())
  userId       String   @unique @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  monthlyLimit Int      @default(4) @map("monthly_limit")
  currentCount Int      @default(0) @map("current_count")
  resetDate    DateTime @default(now()) @map("reset_date")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("appeal_limits")
}

model AppealSubscription {
  id                   String    @id @default(uuid())
  userId               String    @map("user_id")
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  planName             String    @map("plan_name") // e.g., "Premium Appeals"
  appealsIncluded      Int       @map("appeals_included")
  price                Decimal   @db.Decimal(10, 2)
  status               String // ACTIVE, CANCELLED, EXPIRED
  startDate            DateTime  @default(now()) @map("start_date")
  endDate              DateTime? @map("end_date")
  stripeSubscriptionId String?   @unique @map("stripe_subscription_id")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  @@index([userId])
  @@index([status])
  @@map("appeal_subscriptions")
}

// ============================================
// SUBSCRIPTION PLANS
// ============================================

model SubscriptionPlan {
  id              String   @id @default(uuid())
  name            String // "Free", "Premium", "Pro"
  description     String?  @db.Text
  price           Decimal  @db.Decimal(10, 2)
  billingCycle    String // MONTHLY, YEARLY
  features        String   @db.Text // JSON array of features
  appealLimit     Int?     @map("appeal_limit")
  debateLimit     Int?     @map("debate_limit")
  prioritySupport Boolean  @default(false) @map("priority_support")
  customBadge     String?  @map("custom_badge")
  stripePriceId   String?  @unique @map("stripe_price_id")
  stripeProductId String?  @map("stripe_product_id")
  isActive        Boolean  @default(false) @map("is_active") // Don't activate yet
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@index([isActive])
  @@index([billingCycle])
  @@map("subscription_plans")
}

// ============================================
// USER SUBSCRIPTIONS
// ============================================

model UserSubscription {
  id     String @id @default(uuid())
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Subscription Details
  tier               String // FREE, PRO
  billingCycle       String? // MONTHLY, YEARLY (null for FREE)
  status             String    @default("ACTIVE") // ACTIVE, CANCELLED, EXPIRED, PAST_DUE
  currentPeriodStart DateTime? @map("current_period_start")
  currentPeriodEnd   DateTime? @map("current_period_end")

  // Stripe Integration
  stripeCustomerId     String? @unique @map("stripe_customer_id")
  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  stripePriceId        String? @map("stripe_price_id") // For monthly/yearly

  // Promo Code
  promoCodeId String?    @map("promo_code_id")
  promoCode   PromoCode? @relation(fields: [promoCodeId], references: [id])

  // Cancellation
  cancelAtPeriodEnd Boolean   @default(false) @map("cancel_at_period_end")
  cancelledAt       DateTime? @map("cancelled_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([status])
  @@index([tier])
  @@map("user_subscriptions")
}

// ============================================
// PROMO CODES
// ============================================

model PromoCode {
  id          String  @id @default(uuid())
  code        String  @unique // e.g., "WELCOME50"
  description String? @db.Text

  // Discount Type
  discountType  String // PERCENTAGE, FIXED_AMOUNT
  discountValue Decimal @db.Decimal(10, 2) // 50 for 50% or 10.00 for $10 off

  // Usage Limits
  maxUses     Int? @map("max_uses") // null = unlimited
  currentUses Int  @default(0) @map("current_uses")

  // Time Limits
  validFrom  DateTime  @map("valid_from")
  validUntil DateTime? @map("valid_until") // null = no expiration

  // Applicability
  applicableTo  String  @default("PRO") // FREE, PRO, BOTH
  billingCycles String? @map("billing_cycles") // JSON: ["MONTHLY", "YEARLY"] or null for all

  // Status
  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by") // Admin user ID

  // Relations
  subscriptions UserSubscription[]

  @@index([code])
  @@index([isActive])
  @@index([validUntil])
  @@map("promo_codes")
}

// ============================================
// USAGE TRACKING
// ============================================

model UsageTracking {
  id     String @id @default(uuid())
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Feature Usage
  featureType String // APPEAL, TOURNAMENT_CREDIT, THATS_THE_ONE, SPEED_DEBATE
  count       Int    @default(0)

  // Period Tracking
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")
  periodType  String   @default("MONTHLY") // MONTHLY, YEARLY

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([userId, featureType, periodStart])
  @@index([userId])
  @@index([featureType])
  @@index([periodStart])
  @@map("usage_tracking")
}

// ============================================
// ADVERTISEMENTS
// ============================================

model Advertisement {
  id          String    @id @default(uuid())
  title       String
  type        String // BANNER, SPONSORED_DEBATE, IN_FEED
  creativeUrl String    @map("creative_url")
  targetUrl   String    @map("target_url")
  status      String    @default("DRAFT") // DRAFT, ACTIVE, PAUSED
  startDate   DateTime? @map("start_date")
  endDate     DateTime? @map("end_date")
  impressions Int       @default(0)
  clicks      Int       @default(0)
  category    String? // Target specific category
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@index([status])
  @@index([type])
  @@index([category])
  @@map("advertisements")
}

// ============================================
// ADVERTISING SYSTEM - ADVERTISER MODELS
// ============================================

model Advertiser {
  id           String  @id @default(uuid())
  companyName  String  @map("company_name")
  website      String
  industry     String
  contactEmail String  @unique @map("contact_email")
  contactName  String  @map("contact_name")
  businessEIN  String? @map("business_ein")

  // Status management
  status          AdvertiserStatus @default(PENDING)
  stripeAccountId String?          @unique @map("stripe_account_id")
  paymentReady    Boolean          @default(false) @map("payment_ready")

  // Timestamps
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")
  approvedAt       DateTime? @map("approved_at")
  approvedBy       String?   @map("approved_by")
  rejectionReason  String?   @map("rejection_reason") @db.Text
  suspendedAt      DateTime? @map("suspended_at")
  suspensionReason String?   @map("suspension_reason") @db.Text

  // Relations
  campaigns Campaign[]
  offers    Offer[]
  contracts AdContract[]

  @@index([status])
  @@index([contactEmail])
  @@index([createdAt])
  @@map("advertisers")
}

enum AdvertiserStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
  BANNED
}

// ============================================
// CAMPAIGN MODELS
// ============================================

model Campaign {
  id           String     @id @default(uuid())
  advertiserId String     @map("advertiser_id")
  advertiser   Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)

  // Campaign details
  name     String
  type     CampaignType
  category String
  budget   Decimal      @db.Decimal(10, 2)

  // Schedule
  startDate DateTime @map("start_date")
  endDate   DateTime @map("end_date")

  // Creative assets
  bannerUrl      String? @map("banner_url")
  videoUrl       String? @map("video_url")
  destinationUrl String  @map("destination_url")
  ctaText        String  @default("Learn More") @map("cta_text")

  // Targeting (for creator sponsorships)
  minELO              Int?     @map("min_elo")
  targetCategories    String[] @map("target_categories")
  minFollowers        Int?     @map("min_followers")
  maxBudgetPerCreator Decimal? @map("max_budget_per_creator") @db.Decimal(10, 2)

  // Status
  status          CampaignStatus @default(PENDING_REVIEW)
  rejectionReason String?        @map("rejection_reason") @db.Text

  // Timestamps
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  approvedAt DateTime? @map("approved_at")

  // Relations
  offers      Offer[]
  contracts   AdContract[]
  impressions Impression[]
  clicks      Click[]

  @@index([advertiserId])
  @@index([status])
  @@index([startDate, endDate])
  @@index([type])
  @@map("campaigns")
}

enum CampaignType {
  PLATFORM_ADS
  CREATOR_SPONSORSHIP
  TOURNAMENT_SPONSORSHIP
}

enum CampaignStatus {
  PENDING_REVIEW
  APPROVED
  REJECTED
  SCHEDULED
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

// ============================================
// OFFER & CONTRACT MODELS
// ============================================

model Offer {
  id           String     @id @default(uuid())
  advertiserId String     @map("advertiser_id")
  advertiser   Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)
  campaignId   String     @map("campaign_id")
  campaign     Campaign   @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  creatorId    String     @map("creator_id")
  creator      User       @relation("OffersReceived", fields: [creatorId], references: [id], onDelete: Cascade)

  // Offer details
  placement PlacementType
  duration  Int // days

  // Payment structure
  paymentType PaymentType @map("payment_type")
  amount      Decimal     @db.Decimal(10, 2)
  cpcRate     Decimal?    @map("cpc_rate") @db.Decimal(10, 2)
  cpmRate     Decimal?    @map("cpm_rate") @db.Decimal(10, 2)

  // Communication
  message String?     @db.Text
  status  OfferStatus @default(PENDING)

  // Counter offers (negotiation)
  counterAmount    Decimal? @map("counter_amount") @db.Decimal(10, 2)
  counterMessage   String?  @map("counter_message") @db.Text
  negotiationRound Int      @default(0) @map("negotiation_round")

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  expiresAt   DateTime  @map("expires_at")
  respondedAt DateTime? @map("responded_at")

  // Relations
  contract AdContract?

  @@index([creatorId])
  @@index([advertiserId])
  @@index([status])
  @@index([expiresAt])
  @@map("offers")
}

enum PlacementType {
  PROFILE_BANNER
  POST_DEBATE
  DEBATE_WIDGET
  EMAIL_SHOUTOUT
  DEBATE_SPONSORSHIP
}

enum PaymentType {
  FLAT_RATE
  PAY_PER_CLICK
  PAY_PER_IMPRESSION
  PERFORMANCE_BONUS
  REVENUE_SHARE
}

enum OfferStatus {
  PENDING
  ACCEPTED
  DECLINED
  COUNTERED
  EXPIRED
}

model AdContract {
  id      String @id @default(uuid())
  offerId String @unique @map("offer_id")
  offer   Offer  @relation(fields: [offerId], references: [id], onDelete: Cascade)

  // Parties
  advertiserId String     @map("advertiser_id")
  advertiser   Advertiser @relation(fields: [advertiserId], references: [id], onDelete: Cascade)
  creatorId    String     @map("creator_id")
  creator      User       @relation("CreatorContracts", fields: [creatorId], references: [id], onDelete: Cascade)
  campaignId   String     @map("campaign_id")
  campaign     Campaign   @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  // Contract terms
  placement     PlacementType
  totalAmount   Decimal       @map("total_amount") @db.Decimal(10, 2)
  platformFee   Decimal       @map("platform_fee") @db.Decimal(10, 2)
  creatorPayout Decimal       @map("creator_payout") @db.Decimal(10, 2)

  // Schedule
  startDate DateTime @map("start_date")
  endDate   DateTime @map("end_date")

  // Performance tracking
  impressionsDelivered Int @default(0) @map("impressions_delivered")
  clicksDelivered      Int @default(0) @map("clicks_delivered")

  // Status
  status             ContractStatus @default(SCHEDULED)
  signedAt           DateTime       @default(now()) @map("signed_at")
  completedAt        DateTime?      @map("completed_at")
  cancelledAt        DateTime?      @map("cancelled_at")
  cancellationReason String?        @map("cancellation_reason") @db.Text

  // Payment
  escrowHeld      Boolean   @default(false) @map("escrow_held")
  payoutSent      Boolean   @default(false) @map("payout_sent")
  payoutDate      DateTime? @map("payout_date")
  stripePaymentId String?   @map("stripe_payment_id")
  stripePayoutId  String?   @map("stripe_payout_id")

  // Relations
  impressions Impression[]
  clicks      Click[]

  @@index([creatorId])
  @@index([advertiserId])
  @@index([status])
  @@index([endDate])
  @@map("ad_contracts")
}

enum ContractStatus {
  SCHEDULED
  ACTIVE
  COMPLETED
  CANCELLED
  DISPUTED
}

// ============================================
// TRACKING MODELS
// ============================================

model Impression {
  id         String     @id @default(uuid())
  contractId String     @map("contract_id")
  contract   AdContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  campaignId String     @map("campaign_id")
  campaign   Campaign   @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  // Tracking data
  userId    String? @map("user_id")
  ipAddress String  @map("ip_address")
  userAgent String  @map("user_agent")
  referrer  String?

  timestamp DateTime @default(now())

  @@index([contractId])
  @@index([campaignId])
  @@index([timestamp])
  @@index([ipAddress])
  @@map("impressions")
}

model Click {
  id         String     @id @default(uuid())
  contractId String     @map("contract_id")
  contract   AdContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  campaignId String     @map("campaign_id")
  campaign   Campaign   @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  // Tracking data
  userId    String? @map("user_id")
  ipAddress String  @map("ip_address")
  userAgent String  @map("user_agent")
  referrer  String?

  timestamp DateTime @default(now())

  @@index([contractId])
  @@index([campaignId])
  @@index([timestamp])
  @@index([ipAddress])
  @@map("clicks")
}

// ============================================
// CREATOR TAX & PAYOUT MODELS
// ============================================

model CreatorTaxInfo {
  id        String @id @default(uuid())
  creatorId String @unique @map("creator_id")
  creator   User   @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  // Stripe Connect
  stripeAccountId String  @unique @map("stripe_account_id")
  taxFormComplete Boolean @default(false) @map("tax_form_complete")
  bankVerified    Boolean @default(false) @map("bank_verified")
  payoutEnabled   Boolean @default(false) @map("payout_enabled")

  // Earnings tracking (for 1099 generation)
  yearlyEarnings Json @default("{}") @map("yearly_earnings")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("creator_tax_info")
}

enum CreatorStatus {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

// ============================================
// SOCIAL MEDIA POSTS
// ============================================

model SocialMediaPost {
  id          String    @id @default(uuid())
  debateId    String?   @map("debate_id")
  debate      Debate?   @relation(fields: [debateId], references: [id], onDelete: Cascade)
  platform    String // INSTAGRAM, LINKEDIN, TWITTER
  content     String    @db.Text
  imagePrompt String?   @map("image_prompt") @db.Text
  hashtags    String?
  status      String    @default("DRAFT") // DRAFT, APPROVED, PUBLISHED, SCHEDULED
  scheduledAt DateTime? @map("scheduled_at")
  publishedAt DateTime? @map("published_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Marketing system relations
  calendarItemId String?              @unique @map("calendar_item_id")
  calendarItem   ContentCalendarItem? @relation(fields: [calendarItemId], references: [id], onDelete: SetNull)
  strategyId     String?              @map("strategy_id")
  strategy       MarketingStrategy?   @relation(fields: [strategyId], references: [id], onDelete: SetNull)
  analytics      ContentAnalytics[]

  @@index([debateId])
  @@index([platform])
  @@index([status])
  @@index([scheduledAt])
  @@map("social_media_posts")
}

// Marketing Strategy - 12-month AI-generated marketing plan
model MarketingStrategy {
  id          String   @id @default(uuid())
  name        String // e.g., "Q1 2025 Marketing Strategy"
  description String?  @db.Text
  startDate   DateTime @map("start_date")
  endDate     DateTime @map("end_date")
  status      String   @default("DRAFT") // DRAFT, ACTIVE, ARCHIVED
  goals       String?  @db.Text // JSON array of marketing goals
  themes      String?  @db.Text // JSON array of content themes
  platforms   String?  @db.Text // JSON array of platforms to focus on
  frequency   String? // e.g., "3 posts per week"
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  posts         SocialMediaPost[]
  blogPosts     BlogPost[]
  newsletters   EmailNewsletter[]
  calendarItems ContentCalendarItem[]

  @@index([status])
  @@index([startDate])
  @@map("marketing_strategies")
}

// Content Calendar - Scheduled content items
model ContentCalendarItem {
  id               String             @id @default(uuid())
  strategyId       String?            @map("strategy_id")
  strategy         MarketingStrategy? @relation(fields: [strategyId], references: [id], onDelete: SetNull)
  contentType      String             @map("content_type") // SOCIAL_POST, BLOG_POST, NEWSLETTER, VIDEO
  title            String?
  description      String?            @db.Text
  scheduledDate    DateTime           @map("scheduled_date")
  scheduledTime    String?            @map("scheduled_time") // e.g., "09:00"
  status           String             @default("DRAFT") // DRAFT, APPROVED, SCHEDULED, PUBLISHED, CANCELLED
  platform         String? // For social posts: INSTAGRAM, LINKEDIN, TWITTER
  requiresApproval Boolean            @default(true) @map("requires_approval")
  approvedAt       DateTime?          @map("approved_at")
  approvedBy       String?            @map("approved_by")
  createdAt        DateTime           @default(now()) @map("created_at")
  updatedAt        DateTime           @updatedAt @map("updated_at")

  // Relations
  socialPost SocialMediaPost?
  blogPost   BlogPost?
  newsletter EmailNewsletter?

  @@index([scheduledDate])
  @@index([status])
  @@index([contentType])
  @@map("content_calendar_items")
}

// Email Newsletters
model EmailNewsletter {
  id             String               @id @default(uuid())
  strategyId     String?              @map("strategy_id")
  strategy       MarketingStrategy?   @relation(fields: [strategyId], references: [id], onDelete: SetNull)
  subject        String
  content        String               @db.Text
  htmlContent    String?              @map("html_content") @db.Text
  status         String               @default("DRAFT") // DRAFT, SCHEDULED, SENT
  sentAt         DateTime?            @map("sent_at")
  recipientCount Int?                 @map("recipient_count")
  openRate       Float?               @map("open_rate")
  clickRate      Float?               @map("click_rate")
  calendarItemId String?              @unique @map("calendar_item_id")
  calendarItem   ContentCalendarItem? @relation(fields: [calendarItemId], references: [id], onDelete: SetNull)
  createdAt      DateTime             @default(now()) @map("created_at")
  updatedAt      DateTime             @updatedAt @map("updated_at")

  @@index([status])
  @@index([sentAt])
  @@map("email_newsletters")
}

// Content Analytics - Performance metrics
model ContentAnalytics {
  id           String  @id @default(uuid())
  socialPostId String? @map("social_post_id")
  blogPostId   String? @map("blog_post_id")
  contentType  String  @map("content_type") // SOCIAL_POST, BLOG_POST
  platform     String? // For social posts

  // Engagement metrics
  impressions Int @default(0)
  reach       Int @default(0)
  likes       Int @default(0)
  comments    Int @default(0)
  shares      Int @default(0)
  clicks      Int @default(0)
  saves       Int @default(0)

  // Calculated metrics
  engagementRate   Float? @map("engagement_rate")
  clickThroughRate Float? @map("click_through_rate")

  // Relations
  socialPost SocialMediaPost? @relation(fields: [socialPostId], references: [id], onDelete: Cascade)
  blogPost   BlogPost?        @relation(fields: [blogPostId], references: [id], onDelete: Cascade)

  recordedAt DateTime @default(now()) @map("recorded_at")
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([socialPostId])
  @@index([blogPostId])
  @@index([recordedAt])
  @@map("content_analytics")
}

// Session model for authentication
model Session {
  id                String   @id @default(uuid())
  userId            String   @map("user_id")
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token             String   @unique
  expiresAt         DateTime @map("expires_at")
  twoFactorVerified Boolean  @default(false) @map("two_factor_verified") // Whether 2FA has been verified for this session
  createdAt         DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@map("sessions")
}

// ============================================
// DEBATES
// ============================================

model Debate {
  id          String         @id @default(uuid())
  topic       String
  slug        String?        @unique // SEO-friendly URL slug
  description String?
  category    DebateCategory

  // Participants
  challengerId String @map("challenger_id")
  challenger   User   @relation("Challenger", fields: [challengerId], references: [id], onDelete: Cascade)

  opponentId String? @map("opponent_id")
  opponent   User?   @relation("Opponent", fields: [opponentId], references: [id], onDelete: SetNull)

  // Direct Challenge System
  challengeType  String  @default("OPEN") @map("challenge_type") // OPEN, DIRECT, GROUP
  invitedUserIds String? @map("invited_user_ids") // JSON array of user IDs for direct/group challenges
  invitedBy      String? @map("invited_by") // User ID who sent the direct challenge

  // Positions
  challengerPosition DebatePosition @map("challenger_position")
  opponentPosition   DebatePosition @map("opponent_position")

  // Configuration
  totalRounds   Int     @default(5) @map("total_rounds")
  currentRound  Int     @default(1) @map("current_round")
  roundDuration Int     @default(86400000) @map("round_duration") // milliseconds (24h default)
  speedMode     Boolean @default(false) @map("speed_mode")

  // Status
  status DebateStatus @default(WAITING)

  // Verdict
  winnerId       String?   @map("winner_id")
  verdictReached Boolean   @default(false) @map("verdict_reached")
  verdictDate    DateTime? @map("verdict_date")

  // Appeal System
  appealedAt            DateTime?     @map("appealed_at")
  appealStatus          AppealStatus? @map("appeal_status")
  appealCount           Int           @default(0) @map("appeal_count")
  appealedBy            String?       @map("appealed_by") // User ID who appealed
  originalWinnerId      String?       @map("original_winner_id") // Store original winner before appeal
  appealReason          String?       @map("appeal_reason") // User's explanation for why they're appealing
  appealedStatements    String?       @map("appealed_statements") // JSON array of statement IDs being appealed
  appealRejectionReason String?       @map("appeal_rejection_reason") // AI-generated reason when appeal doesn't change verdict

  // Rematch System
  rematchRequestedBy String?        @map("rematch_requested_by") // User ID who requested rematch
  rematchRequestedAt DateTime?      @map("rematch_requested_at")
  rematchStatus      RematchStatus? @map("rematch_status")
  originalDebateId   String?        @map("original_debate_id") // Reference to the original debate if this is a rematch
  rematchDebateId    String?        @map("rematch_debate_id") // Reference to the rematch debate if one was created

  // Metadata
  spectatorCount Int     @default(0) @map("spectator_count")
  viewCount      Int     @default(0) @map("view_count")
  featured       Boolean @default(false)
  allowCopyPaste Boolean @default(true) @map("allow_copy_paste") // Allow copy-paste in arguments

  // Privacy
  isPrivate  Boolean @default(false) @map("is_private") // Private debates require share token
  shareToken String? @unique @map("share_token") // Unique token for sharing private debates

  // Belt at stake indicator
  hasBeltAtStake Boolean @default(false) @map("has_belt_at_stake")
  beltStakeType  String? @map("belt_stake_type") // "CHALLENGE", "TOURNAMENT", "MANDATORY"

  // SEO & Public Access
  visibility DebateVisibility @default(PRIVATE) // PUBLIC, PRIVATE, UNLISTED

  // Relations
  images DebateImage[]

  // ELO changes
  challengerEloChange Int? @map("challenger_elo_change")
  opponentEloChange   Int? @map("opponent_elo_change")

  // Timestamps
  startedAt DateTime? @map("started_at")
  endedAt   DateTime? @map("ended_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  // Round deadlines
  roundDeadline DateTime? @map("round_deadline")

  // Relations
  statements        Statement[]
  verdicts          Verdict[]
  chatMessages      ChatMessage[]
  notifications     Notification[]
  reports           Report[]
  predictions       Prediction[]
  apiUsage          ApiUsage[]
  likes             DebateLike[]
  saves             DebateSave[]
  shares            DebateShare[]
  comments          DebateComment[]
  appealPredictions AppealPrediction[]
  tags              DebateTag[]
  tournamentMatch   TournamentMatch?    @relation("TournamentDebate")
  socialMediaPosts  SocialMediaPost[]
  participants      DebateParticipant[] // Multi-participant support for group challenges

  // Belt relations
  stakedBelt    Belt?          @relation("BeltStakedDebate")
  beltChallenge BeltChallenge? @relation("BeltChallengeDebate")
  beltHistory   BeltHistory[]  @relation("BeltHistoryDebate")

  @@index([status])
  @@index([category])
  @@index([createdAt])
  @@index([challengerId])
  @@index([opponentId])
  @@index([slug])
  @@map("debates")
}

enum DebateCategory {
  SPORTS
  POLITICS
  TECH
  ENTERTAINMENT
  SCIENCE
  MUSIC
  OTHER
}

enum DebatePosition {
  FOR
  AGAINST
}

enum DebateVisibility {
  PUBLIC // Publicly indexable and visible
  PRIVATE // Only accessible via share token
  UNLISTED // Accessible via direct link but not indexed
}

enum DebateStatus {
  WAITING // Waiting for opponent
  ACTIVE // Debate in progress
  COMPLETED // Debate finished, awaiting verdict
  VERDICT_READY // AI judges decided
  APPEALED // Verdict appealed, awaiting re-verdict
  CANCELLED // Cancelled before completion
}

enum AppealStatus {
  PENDING // Appeal submitted, awaiting new verdict
  PROCESSING // New verdict being generated
  RESOLVED // Appeal resolved with new verdict
  DENIED // Appeal denied (if we add validation)
}

enum RematchStatus {
  PENDING // Rematch requested, awaiting response
  ACCEPTED // Rematch accepted, debate created
  DECLINED // Rematch declined
}

// ============================================
// DEBATE PARTICIPANTS (Multi-participant support)
// ============================================

model DebateParticipant {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation("DebateParticipants", fields: [userId], references: [id], onDelete: Cascade)

  position  DebatePosition // FOR or AGAINST
  status    String         @default("INVITED") // INVITED, ACCEPTED, DECLINED, ACTIVE, ELIMINATED
  joinedAt  DateTime?      @map("joined_at")
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@index([status])
  @@map("debate_participants")
}

// ============================================
// STATEMENTS (Arguments)
// ============================================

model Statement {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  authorId String @map("author_id")
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  round   Int
  content String

  // Moderation
  flagged       Boolean   @default(false)
  flaggedReason String?   @map("flagged_reason")
  moderatedAt   DateTime? @map("moderated_at")

  // AI Moderation
  aiModerated   Boolean   @default(false) @map("ai_moderated")
  aiAction      String?   @map("ai_action") // APPROVE, REMOVE, ESCALATE
  aiConfidence  Int?      @map("ai_confidence") // 0-100
  aiReasoning   String?   @map("ai_reasoning")
  aiSeverity    String?   @map("ai_severity") // LOW, MEDIUM, HIGH, CRITICAL
  aiModeratedAt DateTime? @map("ai_moderated_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([debateId, authorId, round])
  @@index([debateId])
  @@index([authorId])
  @@map("statements")
}

// ============================================
// DEBATE IMAGES
// ============================================

model DebateImage {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  url     String // Image URL or path
  alt     String? // Alt text for accessibility
  caption String? // Optional caption/description
  order   Int     @default(0) // Display order

  // Metadata
  width    Int?
  height   Int?
  fileSize Int?    @map("file_size")
  mimeType String? @map("mime_type")

  // Upload info
  uploadedBy String?  @map("uploaded_by") // User ID
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([debateId])
  @@index([order])
  @@map("debate_images")
}

// ============================================
// AI JUDGES
// ============================================

model Judge {
  id          String @id @default(uuid())
  name        String @unique
  personality String
  emoji       String
  description String

  // System prompt for this judge
  systemPrompt String @map("system_prompt") // Store as text in SQLite

  // Stats
  debatesJudged Int @default(0) @map("debates_judged")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  verdicts    Verdict[]
  tournaments Tournament[]

  @@map("judges")
}

// ============================================
// VERDICTS
// ============================================

model Verdict {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  judgeId String @map("judge_id")
  judge   Judge  @relation(fields: [judgeId], references: [id], onDelete: Cascade)

  // Decision
  winnerId  String?         @map("winner_id")
  decision  VerdictDecision
  reasoning String

  // Scores
  challengerScore Int? @map("challenger_score") // 0-100
  opponentScore   Int? @map("opponent_score") // 0-100

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, judgeId])
  @@index([debateId])
  @@map("verdicts")
}

enum VerdictDecision {
  CHALLENGER_WINS
  OPPONENT_WINS
  TIE
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id     String @id @default(uuid())
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String

  // Optional debate reference
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: Cascade)

  read   Boolean   @default(false)
  readAt DateTime? @map("read_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([read])
  @@map("notifications")
}

model FCMToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("FCMTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  device    String? // Browser/device identifier (e.g., "Chrome", "Safari", "Mobile App")
  userAgent String?  @map("user_agent")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("fcm_tokens")
}

enum NotificationType {
  DEBATE_TURN // Your turn to argue
  DEBATE_ACCEPTED // Your challenge was accepted
  ROUND_ENDING // Round ending soon
  VERDICT_READY // AI judges decided
  DEBATE_WON // You won
  DEBATE_LOST // You lost
  DEBATE_TIED // Debate tied
  NEW_CHALLENGE // Someone challenged you
  OPPONENT_SUBMITTED // Opponent submitted argument
  DEBATE_INVITATION // Direct challenge invitation
  DEBATE_GROUP_INVITATION // Group challenge invitation
  REMATCH_REQUESTED // Someone requested a rematch
  REMATCH_ACCEPTED // Rematch was accepted
  REMATCH_DECLINED // Rematch was declined
  NEW_MESSAGE // New direct message received
  BELT_CHALLENGE // Belt challenge received
  BELT_CHALLENGE_ACCEPTED // Belt challenge accepted
  BELT_MANDATORY_DEFENSE // Belt requires mandatory defense
  BELT_INACTIVE // Belt became inactive
  BELT_TRANSFER // Belt transferred (won/lost)
}

// ============================================
// CHAT
// ============================================

model ChatMessage {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  authorId String @map("author_id")
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  content String

  // Moderation
  deleted   Boolean   @default(false)
  deletedAt DateTime? @map("deleted_at")
  deletedBy String?   @map("deleted_by")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([debateId])
  @@index([authorId])
  @@index([createdAt])
  @@map("chat_messages")
}

// ============================================
// MODERATION
// ============================================

model Report {
  id String @id @default(uuid())

  // What's being reported
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Who reported
  reporterId String @map("reporter_id")
  reporter   User   @relation(fields: [reporterId], references: [id], onDelete: Cascade)

  // Report details
  reason      String
  description String?

  // Status
  status     ReportStatus @default(PENDING)
  reviewedBy String?      @map("reviewed_by")
  reviewedAt DateTime?    @map("reviewed_at")
  resolution String?

  // AI Moderation
  aiModerated   Boolean   @default(false) @map("ai_moderated")
  aiAction      String?   @map("ai_action") // APPROVE, REMOVE, ESCALATE
  aiConfidence  Int?      @map("ai_confidence") // 0-100
  aiReasoning   String?   @map("ai_reasoning")
  aiSeverity    String?   @map("ai_severity") // LOW, MEDIUM, HIGH, CRITICAL
  aiModeratedAt DateTime? @map("ai_moderated_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([status])
  @@index([aiModerated])
  @@map("reports")
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

// ============================================
// PREDICTIONS (Spectator betting)
// ============================================

model Prediction {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Prediction
  predictedWinnerId String @map("predicted_winner_id")
  confidence        Int // 1-5 stars

  // Result
  correct Boolean?
  points  Int? // Points earned/lost

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([userId])
  @@map("predictions")
}

// ============================================
// ADMIN SETTINGS (API Keys)
// ============================================

model AdminSetting {
  id    String @id @default(uuid())
  key   String @unique
  value String

  // Encryption flag
  encrypted Boolean @default(false)

  // Metadata
  description String?
  category    String?

  updatedBy String?  @map("updated_by")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([category])
  @@map("admin_settings")
}

// Waiting list for users when user limit is reached
model WaitingList {
  id           String    @id @default(uuid())
  email        String    @unique
  username     String    @unique
  passwordHash String    @map("password_hash") // Store hashed password for when they're approved
  position     Int // Position in waiting list (1 = first, 2 = second, etc.)
  notified     Boolean   @default(false) @map("notified") // Whether they've been notified
  approved     Boolean   @default(false) @map("approved") // Whether they've been approved to join
  approvedAt   DateTime? @map("approved_at")
  approvedBy   String?   @map("approved_by") // Admin who approved them

  // Metadata
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([email])
  @@index([position])
  @@index([approved])
  @@map("waiting_list")
}

// ============================================
// API USAGE TRACKING
// ============================================

model ApiUsage {
  id String @id @default(uuid())

  // API Details
  provider String // e.g., "deepseek", "openai", "resend"
  endpoint String // e.g., "chat/completions"
  model    String? // e.g., "deepseek-chat"

  // Request/Response Metrics
  promptTokens     Int? @map("prompt_tokens")
  completionTokens Int? @map("completion_tokens")
  totalTokens      Int? @map("total_tokens")

  // Cost Calculation
  cost            Float  @default(0) // Cost in USD
  costPer1kTokens Float? @map("cost_per_1k_tokens") // Cost per 1k tokens

  // Context
  debateId String? @map("debate_id")
  debate   Debate? @relation(fields: [debateId], references: [id], onDelete: SetNull)
  userId   String? @map("user_id")
  user     User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Status
  success      Boolean @default(true)
  errorMessage String? @map("error_message")

  // Metadata
  responseTime Int?    @map("response_time") // in milliseconds
  metadata     String? // JSON string for additional data

  createdAt DateTime @default(now()) @map("created_at")

  @@index([provider])
  @@index([debateId])
  @@index([userId])
  @@index([createdAt])
  @@map("api_usage")
}

// ============================================
// SEED DEBATES (AI-generated sample debates)
// ============================================

model SeedDebate {
  id             String         @id @default(uuid())
  topic          String
  category       DebateCategory
  challengerName String         @map("challenger_name")
  opponentName   String         @map("opponent_name")

  // Pre-generated content (stored as JSON strings in SQLite)
  statements  String // JSON string
  verdictData String @map("verdict_data") // JSON string

  featured Boolean @default(false)

  createdAt DateTime @default(now()) @map("created_at")

  @@index([category])
  @@map("seed_debates")
}

// ============================================
// DEBATE INTERACTIONS & SOCIAL FEATURES
// ============================================

// Like a debate
model DebateLike {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@map("debate_likes")
}

// Save/bookmark a debate
model DebateSave {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([debateId, userId])
  @@index([debateId])
  @@index([userId])
  @@map("debate_saves")
}

// Share a debate
model DebateShare {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Share method (optional tracking)
  method String? // e.g., "twitter", "facebook", "copy_link"

  createdAt DateTime @default(now()) @map("created_at")

  @@index([debateId])
  @@index([userId])
  @@map("debate_shares")
}

// Comment on a debate
model DebateComment {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  userId   String @map("user_id")
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  content String

  // Optional: Reply to another comment
  parentId String?         @map("parent_id")
  parent   DebateComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  DebateComment[] @relation("CommentReplies")

  // Moderation
  deleted   Boolean   @default(false)
  deletedAt DateTime? @map("deleted_at")
  deletedBy String?   @map("deleted_by")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([debateId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("debate_comments")
}

// Follow another user
model Follow {
  id          String @id @default(uuid())
  followerId  String @map("follower_id")
  follower    User   @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  followingId String @map("following_id")
  following   User   @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

// ============================================
// TAGS
// ============================================

model Tag {
  id         String   @id @default(uuid())
  name       String   @unique
  color      String   @default("#00aaff")
  usageCount Int      @default(0) @map("usage_count")
  createdAt  DateTime @default(now()) @map("created_at")

  debateTags DebateTag[]

  @@index([name])
  @@index([usageCount])
  @@map("tags")
}

model DebateTag {
  id        String   @id @default(uuid())
  debateId  String   @map("debate_id")
  tagId     String   @map("tag_id")
  createdAt DateTime @default(now()) @map("created_at")

  debate Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([debateId, tagId])
  @@index([debateId])
  @@index([tagId])
  @@map("debate_tags")
}

// ============================================
// LLM MODEL MANAGEMENT
// ============================================

// Model versions for tracking different LLM models
model ModelVersion {
  id          String  @id @default(uuid())
  name        String // e.g., "Appeal Predictor v1.0"
  version     String // e.g., "1.0.0"
  description String?
  modelType   String  @map("model_type") // e.g., "appeal_predictor", "verdict_judge"

  // Configuration
  config String? // JSON string for model configuration (hyperparameters, etc.)

  // Status
  isActive  Boolean @default(false) @map("is_active")
  isDefault Boolean @default(false) @map("is_default")

  // Metadata
  createdBy String?  @map("created_by")
  creator   User?    @relation("ModelCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  metrics           ModelMetric[]
  abTestsA          ABTest[]           @relation("ABTestModelA")
  abTestsB          ABTest[]           @relation("ABTestModelB")
  appealPredictions AppealPrediction[]

  @@unique([name, version])
  @@index([modelType])
  @@index([isActive])
  @@map("model_versions")
}

// ============================================
// CATEGORIES
// ============================================

model Category {
  id          String  @id @default(uuid())
  name        String  @unique // e.g., "SPORTS", "TECH"
  label       String // Display name e.g., "Sports", "Tech"
  description String?
  color       String? // Hex color for UI
  icon        String? // Icon/emoji
  isActive    Boolean @default(true) @map("is_active")
  sortOrder   Int     @default(0) @map("sort_order")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("categories")
}

// Performance metrics for model versions
model ModelMetric {
  id             String       @id @default(uuid())
  modelVersionId String       @map("model_version_id")
  modelVersion   ModelVersion @relation(fields: [modelVersionId], references: [id], onDelete: Cascade)

  // Metrics
  metricType  String @map("metric_type") // e.g., "accuracy", "precision", "recall", "f1_score"
  metricValue Float  @map("metric_value")

  // Context
  dataset String? // e.g., "training", "validation", "test"
  period  String? // e.g., "daily", "weekly", "monthly"

  // Metadata
  recordedAt DateTime @default(now()) @map("recorded_at")
  notes      String?

  @@index([modelVersionId])
  @@index([metricType])
  @@index([recordedAt])
  @@map("model_metrics")
}

// A/B Testing for model comparison
model ABTest {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Models being tested
  modelVersionAId String       @map("model_version_a_id")
  modelVersionA   ModelVersion @relation("ABTestModelA", fields: [modelVersionAId], references: [id], onDelete: Cascade)

  modelVersionBId String       @map("model_version_b_id")
  modelVersionB   ModelVersion @relation("ABTestModelB", fields: [modelVersionBId], references: [id], onDelete: Cascade)

  // Configuration
  trafficSplit Int       @default(50) @map("traffic_split") // Percentage for model A (0-100)
  startDate    DateTime  @map("start_date")
  endDate      DateTime? @map("end_date")

  // Status
  status   String  @default("draft") // draft, active, completed, cancelled
  isActive Boolean @default(false) @map("is_active")

  // Results
  modelAScore Float?  @map("model_a_score")
  modelBScore Float?  @map("model_b_score")
  winner      String? // "A", "B", or "tie"

  // Metadata
  createdBy String?  @map("created_by")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([status])
  @@index([isActive])
  @@index([startDate])
  @@map("ab_tests")
}

// Appeal success prediction tracking
model AppealPrediction {
  id       String @id @default(uuid())
  debateId String @map("debate_id")
  debate   Debate @relation(fields: [debateId], references: [id], onDelete: Cascade)

  // Model used
  modelVersionId String?       @map("model_version_id")
  modelVersion   ModelVersion? @relation(fields: [modelVersionId], references: [id], onDelete: SetNull)

  // Prediction
  predictedSuccess Boolean @map("predicted_success") // Will the appeal succeed?
  confidence       Float // 0.0 to 1.0
  reasoning        String? // Model's reasoning

  // Actual result
  actualSuccess Boolean? @map("actual_success") // Did appeal actually succeed?

  // Metadata
  predictedAt DateTime  @default(now()) @map("predicted_at")
  resolvedAt  DateTime? @map("resolved_at")

  @@unique([debateId])
  @@index([modelVersionId])
  @@index([predictedSuccess])
  @@index([actualSuccess])
  @@map("appeal_predictions")
}

// ============================================
// HOMEPAGE CONTENT MANAGEMENT
// ============================================

// Homepage sections (Hero, Features, How It Works, etc.)
model HomepageSection {
  id        String  @id @default(uuid())
  key       String  @unique // e.g., "hero", "features", "how-it-works"
  title     String? // Section title
  content   String? // Rich text content (HTML or markdown)
  order     Int     @default(0) // Display order
  isVisible Boolean @default(true) @map("is_visible")

  // Footer-specific fields
  contactEmail String? @map("contact_email") // Contact email for footer section

  // SEO
  metaTitle       String? @map("meta_title")
  metaDescription String? @map("meta_description")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  images  HomepageImage[]
  buttons HomepageButton[]

  @@index([key])
  @@index([order])
  @@index([isVisible])
  @@map("homepage_sections")
}

// Images for homepage sections
model HomepageImage {
  id        String          @id @default(uuid())
  sectionId String          @map("section_id")
  section   HomepageSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  url           String // Image URL or path
  alt           String? // Alt text
  caption       String? // Image caption
  linkUrl       String? @map("link_url") // Optional link URL for clickable images (e.g., App Store/Google Play links)
  order         Int     @default(0) // Display order within section
  imagePosition String? @default("left") @map("image_position") // "left" or "right" - where image appears relative to content

  // Metadata
  width    Int?
  height   Int?
  fileSize Int?    @map("file_size")
  mimeType String? @map("mime_type")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([sectionId])
  @@index([order])
  @@map("homepage_images")
}

// Buttons/CTAs for homepage sections
model HomepageButton {
  id        String          @id @default(uuid())
  sectionId String          @map("section_id")
  section   HomepageSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  text    String // Button text
  url     String? // Link URL (e.g., "/signup", "/login")
  variant String  @default("primary") // Button style
  order   Int     @default(0) // Display order

  isVisible Boolean @default(true) @map("is_visible")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([sectionId])
  @@index([order])
  @@map("homepage_buttons")
}

// Media library for all uploaded images
model MediaLibrary {
  id       String  @id @default(uuid())
  url      String  @unique // File path or URL
  filename String // Original filename
  alt      String? // Alt text
  caption  String? // Caption

  // File metadata
  width    Int?
  height   Int?
  fileSize Int    @map("file_size")
  mimeType String @map("mime_type")

  // Usage tracking
  usedIn String? @map("used_in") // e.g., "homepage:hero", "homepage:features"

  // Upload metadata
  uploadedBy String?  @map("uploaded_by") // User ID
  uploadedAt DateTime @default(now()) @map("uploaded_at")

  // Relations
  featuredInBlogPosts BlogPost[] @relation("BlogPostFeaturedImage")

  @@index([usedIn])
  @@index([uploadedBy])
  @@index([uploadedAt])
  @@map("media_library")
}

// Legal pages (Terms of Service, Privacy Policy, etc.)
model LegalPage {
  id        String  @id @default(uuid())
  slug      String  @unique // e.g., "terms", "privacy"
  title     String // Page title
  content   String // Rich text content (HTML)
  isVisible Boolean @default(true) @map("is_visible")

  // SEO
  metaTitle       String? @map("meta_title")
  metaDescription String? @map("meta_description")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([slug])
  @@index([isVisible])
  @@map("legal_pages")
}

// Static pages (how-it-works, pricing, about, faq)
model StaticPage {
  id        String  @id @default(uuid())
  slug      String  @unique // e.g., "how-it-works", "pricing", "about", "faq"
  title     String // Page title
  content   String // Rich text content (HTML)
  isVisible Boolean @default(true) @map("is_visible")

  // SEO
  metaTitle       String? @map("meta_title")
  metaDescription String? @map("meta_description")
  keywords        String? // Comma-separated keywords

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([slug])
  @@index([isVisible])
  @@map("static_pages")
}

// Social media links for footer
model SocialMediaLink {
  id       String  @id @default(uuid())
  platform String  @unique // FACEBOOK, TWITTER, INSTAGRAM, LINKEDIN, YOUTUBE, TIKTOK
  url      String
  order    Int     @default(0)
  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([platform])
  @@index([isActive])
  @@index([order])
  @@map("social_media_links")
}

// ============================================
// TOURNAMENTS
// ============================================

enum TournamentStatus {
  UPCOMING
  REGISTRATION_OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TournamentFormat {
  BRACKET // Traditional bracket elimination (current system)
  CHAMPIONSHIP // Position-based, score-advancement format (new)
  KING_OF_THE_HILL // Free-for-all elimination format
}

enum ReseedMethod {
  ELO_BASED
  TOURNAMENT_WINS
  RANDOM
}

enum ParticipantStatus {
  REGISTERED
  ACTIVE
  ELIMINATED
  DISQUALIFIED
}

enum RoundStatus {
  UPCOMING
  IN_PROGRESS
  COMPLETED
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  FORFEITED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}

// ============================================
// BELT SYSTEM ENUMS
// ============================================

enum BeltType {
  ROOKIE // First belt earned
  CATEGORY // Category-specific belt (Sports, Politics, etc.)
  CHAMPIONSHIP // Cross-category, highest tier
  UNDEFEATED // Streak-based belt
  TOURNAMENT // Tournament-specific belt
}

enum BeltStatus {
  ACTIVE // Currently held, can be challenged
  INACTIVE // Not defended for X days, top competitors can compete
  VACANT // No holder, anyone can claim
  STAKED // Currently at risk in a debate/tournament
  GRACE_PERIOD // First 30 days, protected from loss
  MANDATORY // Mandatory defense required
}

enum ChallengeStatus {
  PENDING // Challenge sent, awaiting response
  ACCEPTED // Challenge accepted, debate created
  DECLINED // Challenge declined
  EXPIRED // Challenge expired (time limit)
  CANCELLED // Challenge cancelled by challenger
  COMPLETED // Challenge completed, belt transferred
}

enum BeltTransferReason {
  DEBATE_WIN // Lost belt in a debate
  TOURNAMENT_WIN // Lost belt in a tournament
  MANDATORY_LOSS // Lost in mandatory defense
  INACTIVITY // Lost due to inactivity
  ADMIN_TRANSFER // Manually transferred by admin
  CHALLENGE_WIN // Won belt via challenge
  FORFEIT // Forfeited belt
}

model Tournament {
  id          String  @id @default(uuid())
  name        String
  description String?
  creatorId   String  @map("creator_id")
  creator     User    @relation("TournamentCreator", fields: [creatorId], references: [id])

  // Settings
  maxParticipants Int              @default(16) @map("max_participants")
  currentRound    Int              @default(1) @map("current_round")
  totalRounds     Int              @map("total_rounds")
  status          TournamentStatus @default(UPCOMING)

  // Privacy & Invitations
  isPrivate      Boolean @default(false) @map("is_private")
  invitedUserIds String? @map("invited_user_ids") // JSON array of user IDs

  // Requirements
  minElo  Int?    @map("min_elo")
  judgeId String? @map("judge_id")
  judge   Judge?  @relation(fields: [judgeId], references: [id])

  // Timing
  startDate     DateTime  @map("start_date")
  endDate       DateTime? @map("end_date")
  roundDuration Int       @map("round_duration") // Hours per round

  // Reseeding
  reseedAfterRound Boolean      @default(true) @map("reseed_after_round")
  reseedMethod     ReseedMethod @default(ELO_BASED) @map("reseed_method")

  // Format (Championship vs Bracket)
  format         TournamentFormat @default(BRACKET)
  assignedJudges String?          @map("assigned_judges") // JSON array of judge IDs (Championship format only)

  // Belt creation
  beltCreated      Boolean @default(false) @map("belt_created")
  beltCreationCost Int?    @map("belt_creation_cost") // Coins paid
  beltCreatedBy    String? @map("belt_created_by") // User ID who paid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  participants TournamentParticipant[]
  matches      TournamentMatch[]
  rounds       TournamentRound[]

  // Belt relations
  tournamentBelt Belt?         @relation("TournamentBelt")
  stakedBelts    Belt[]        @relation("BeltStakedTournament")
  beltHistory    BeltHistory[] @relation("BeltHistoryTournament")

  @@index([creatorId])
  @@index([status])
  @@map("tournaments")
}

model TournamentParticipant {
  id           String     @id @default(uuid())
  tournamentId String     @map("tournament_id")
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  userId       String     @map("user_id")
  user         User       @relation("TournamentParticipant", fields: [userId], references: [id])

  // Tournament-specific stats
  seed        Int?
  currentSeed Int? @map("current_seed")
  wins        Int  @default(0)
  losses      Int  @default(0)
  eloAtStart  Int  @map("elo_at_start")

  // Position selection (Championship format only)
  selectedPosition String? @map("selected_position") // 'PRO' or 'CON'

  // King of the Hill specific fields
  cumulativeScore   Int?    @map("cumulative_score") // Total score across all rounds
  eliminationRound  Int?    @map("elimination_round") // Round in which participant was eliminated
  eliminationReason String? @map("elimination_reason") // AI explanation for elimination

  // Status
  status       ParticipantStatus @default(REGISTERED)
  eliminatedAt DateTime?         @map("eliminated_at")

  registeredAt DateTime @default(now()) @map("registered_at")

  matches1   TournamentMatch[] @relation("Participant1")
  matches2   TournamentMatch[] @relation("Participant2")
  wonMatches TournamentMatch[] @relation("MatchWinner")

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@index([userId])
  @@map("tournament_participants")
}

model TournamentRound {
  id           String     @id @default(uuid())
  tournamentId String     @map("tournament_id")
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  roundNumber Int         @map("round_number")
  status      RoundStatus @default(UPCOMING)
  startDate   DateTime?   @map("start_date")
  endDate     DateTime?   @map("end_date")

  matches TournamentMatch[]

  @@unique([tournamentId, roundNumber])
  @@index([tournamentId])
  @@map("tournament_rounds")
}

model TournamentMatch {
  id           String          @id @default(uuid())
  tournamentId String          @map("tournament_id")
  tournament   Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  roundId      String          @map("round_id")
  round        TournamentRound @relation(fields: [roundId], references: [id])

  participant1Id String                @map("participant1_id")
  participant1   TournamentParticipant @relation("Participant1", fields: [participant1Id], references: [id])
  participant2Id String                @map("participant2_id")
  participant2   TournamentParticipant @relation("Participant2", fields: [participant2Id], references: [id])

  // Link to actual debate
  debateId String? @unique @map("debate_id")
  debate   Debate? @relation("TournamentDebate", fields: [debateId], references: [id])

  // Match result
  winnerId String?                @map("winner_id")
  winner   TournamentParticipant? @relation("MatchWinner", fields: [winnerId], references: [id])
  status   MatchStatus            @default(SCHEDULED)

  // Individual scores (Championship format)
  participant1Score          Int?  @map("participant1_score") // 0-100 average score
  participant2Score          Int?  @map("participant2_score") // 0-100 average score
  participant1ScoreBreakdown Json? @map("participant1_score_breakdown") // { judgeId: score } for all judges
  participant2ScoreBreakdown Json? @map("participant2_score_breakdown") // { judgeId: score } for all judges

  scheduledAt DateTime? @map("scheduled_at")
  completedAt DateTime? @map("completed_at")

  @@index([tournamentId])
  @@index([roundId])
  @@index([debateId])
  @@map("tournament_matches")
}

model TournamentSubscription {
  id     String @id @default(uuid())
  userId String @unique @map("user_id")
  user   User   @relation(fields: [userId], references: [id])

  stripeSubscriptionId String? @unique @map("stripe_subscription_id")
  stripeCustomerId     String? @map("stripe_customer_id")

  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime           @map("current_period_start")
  currentPeriodEnd   DateTime           @map("current_period_end")

  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  cancelledAt DateTime? @map("cancelled_at")

  @@index([userId])
  @@index([status])
  @@map("tournament_subscriptions")
}

// ============================================
// SUPPORT TICKETS
// ============================================

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum SupportTicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model SupportTicket {
  id     String @id @default(uuid())
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  subject     String
  description String
  category    String? // e.g., "Technical", "Billing", "Feature Request", "Bug Report"

  status   SupportTicketStatus   @default(OPEN)
  priority SupportTicketPriority @default(MEDIUM)

  // Admin assignment
  assignedToId String? @map("assigned_to_id")
  assignedTo   User?   @relation("AssignedTickets", fields: [assignedToId], references: [id])

  // Replies
  replies SupportTicketReply[]

  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  resolvedAt DateTime? @map("resolved_at")
  closedAt   DateTime? @map("closed_at")

  @@index([userId])
  @@index([status])
  @@index([assignedToId])
  @@index([createdAt])
  @@map("support_tickets")
}

model SupportTicketReply {
  id       String        @id @default(uuid())
  ticketId String        @map("ticket_id")
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  authorId String @map("author_id")
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  content    String
  isInternal Boolean @default(false) @map("is_internal") // Internal notes visible only to admins

  createdAt DateTime @default(now()) @map("created_at")

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
  @@map("support_ticket_replies")
}

// ============================================
// DIRECT MESSAGES
// ============================================

model Conversation {
  id      String @id @default(uuid())
  user1Id String @map("user1_id")
  user1   User   @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id String @map("user2_id")
  user2   User   @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)

  // Last message info for sorting
  lastMessageId String?   @map("last_message_id")
  lastMessageAt DateTime? @map("last_message_at")

  // Read status
  user1LastReadAt DateTime? @map("user1_last_read_at")
  user2LastReadAt DateTime? @map("user2_last_read_at")

  messages DirectMessage[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([lastMessageAt])
  @@map("conversations")
}

model DirectMessage {
  id             String       @id @default(uuid())
  conversationId String       @map("conversation_id")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId String @map("sender_id")
  sender   User   @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)

  receiverId String @map("receiver_id")
  receiver   User   @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  content String
  isRead  Boolean   @default(false) @map("is_read")
  readAt  DateTime? @map("read_at")

  // Deletion (soft delete - user can delete their own messages)
  deletedBySender   Boolean @default(false) @map("deleted_by_sender")
  deletedByReceiver Boolean @default(false) @map("deleted_by_receiver")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("direct_messages")
}

// ============================================
// BLOG SYSTEM
// ============================================

enum BlogPostStatus {
  DRAFT
  PUBLISHED
  SCHEDULED
  ARCHIVED
}

model BlogPost {
  id      String  @id @default(uuid())
  slug    String  @unique // URL-friendly slug (auto-generated from title)
  title   String
  excerpt String? @db.Text // Short description for listings
  content String  @db.Text // Full blog post content (HTML)

  // SEO Fields
  metaTitle       String? @map("meta_title") // Custom SEO title (defaults to title)
  metaDescription String? @map("meta_description") // Meta description
  keywords        String? // Comma-separated keywords
  ogImage         String? @map("og_image") // Open Graph image URL

  // Publishing
  status      BlogPostStatus @default(DRAFT) // DRAFT, PUBLISHED, SCHEDULED, ARCHIVED
  publishedAt DateTime?      @map("published_at") // When to publish (for scheduled)

  // Author
  authorId String @map("author_id")
  author   User   @relation("BlogPostAuthor", fields: [authorId], references: [id])

  // Media
  featuredImageId String?       @map("featured_image_id")
  featuredImage   MediaLibrary? @relation("BlogPostFeaturedImage", fields: [featuredImageId], references: [id], onDelete: SetNull)

  // Categories & Tags
  categories BlogPostToCategory[]
  tags       BlogPostToTag[]

  // Marketing System Relations
  strategyId     String?              @map("strategy_id")
  strategy       MarketingStrategy?   @relation(fields: [strategyId], references: [id], onDelete: SetNull)
  calendarItemId String?              @unique @map("calendar_item_id")
  calendarItem   ContentCalendarItem? @relation(fields: [calendarItemId], references: [id], onDelete: SetNull)
  analytics      ContentAnalytics[]

  // Analytics
  views    Int     @default(0)
  featured Boolean @default(false) // Featured on homepage

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([slug])
  @@index([status])
  @@index([publishedAt])
  @@index([authorId])
  @@index([featured])
  @@index([createdAt])
  @@map("blog_posts")
}

model BlogPostCategory {
  id          String               @id @default(uuid())
  name        String               @unique
  slug        String               @unique
  description String?              @db.Text
  posts       BlogPostToCategory[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([slug])
  @@map("blog_post_categories")
}

model BlogPostTag {
  id    String          @id @default(uuid())
  name  String          @unique
  slug  String          @unique
  posts BlogPostToTag[]

  createdAt DateTime @default(now()) @map("created_at")

  @@index([slug])
  @@map("blog_post_tags")
}

// Many-to-many relations
model BlogPostToCategory {
  postId     String           @map("post_id")
  categoryId String           @map("category_id")
  post       BlogPost         @relation(fields: [postId], references: [id], onDelete: Cascade)
  category   BlogPostCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([postId, categoryId])
  @@index([postId])
  @@index([categoryId])
  @@map("blog_post_to_categories")
}

model BlogPostToTag {
  postId String      @map("post_id")
  tagId  String      @map("tag_id")
  post   BlogPost    @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    BlogPostTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("blog_post_to_tags")
}

// Trello-like Kanban Board System
model Board {
  id          String   @id @default(uuid())
  name        String
  description String?
  color       String?  @default("#0079bf") // Trello blue
  isArchived  Boolean  @default(false) @map("is_archived")
  lists       List[]
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@index([isArchived])
  @@map("boards")
}

model List {
  id         String   @id @default(uuid())
  boardId    String   @map("board_id")
  board      Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
  name       String
  position   Int      @default(0) // For ordering lists
  isArchived Boolean  @default(false) @map("is_archived")
  cards      Card[]
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([boardId])
  @@index([position])
  @@map("lists")
}

model Card {
  id           String            @id @default(uuid())
  listId       String            @map("list_id")
  list         List              @relation(fields: [listId], references: [id], onDelete: Cascade)
  title        String
  description  String? // Rich text description
  position     Int               @default(0) // For ordering cards within a list
  dueDate      DateTime?         @map("due_date")
  startDate    DateTime?         @map("start_date")
  reminderDate DateTime?         @map("reminder_date")
  location     String? // Address or location name
  latitude     Float? // For map view
  longitude    Float? // For map view
  isArchived   Boolean           @default(false) @map("is_archived")
  labels       CardLabel[]
  checklists   CardChecklist[]
  members      CardMember[]
  attachments  CardAttachment[]
  customFields CardCustomField[]
  createdAt    DateTime          @default(now()) @map("created_at")
  updatedAt    DateTime          @updatedAt @map("updated_at")

  @@index([listId])
  @@index([position])
  @@map("cards")
}

model CardLabel {
  id        String   @id @default(uuid())
  cardId    String   @map("card_id")
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  name      String
  color     String   @default("#61bd4f") // Green default
  createdAt DateTime @default(now()) @map("created_at")

  @@index([cardId])
  @@map("card_labels")
}

// Checklist for cards (subtasks)
model CardChecklist {
  id        String              @id @default(uuid())
  cardId    String              @map("card_id")
  card      Card                @relation(fields: [cardId], references: [id], onDelete: Cascade)
  title     String              @default("Checklist")
  items     CardChecklistItem[]
  position  Int                 @default(0)
  createdAt DateTime            @default(now()) @map("created_at")
  updatedAt DateTime            @updatedAt @map("updated_at")

  @@index([cardId])
  @@map("card_checklists")
}

model CardChecklistItem {
  id          String        @id @default(uuid())
  checklistId String        @map("checklist_id")
  checklist   CardChecklist @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  text        String
  isCompleted Boolean       @default(false) @map("is_completed")
  position    Int           @default(0)
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  @@index([checklistId])
  @@map("card_checklist_items")
}

// Members assigned to cards
model CardMember {
  id        String   @id @default(uuid())
  cardId    String   @map("card_id")
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  userId    String   @map("user_id")
  user      User     @relation("CardMembers", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([cardId, userId])
  @@index([cardId])
  @@index([userId])
  @@map("card_members")
}

// Attachments (links, files, work items)
model CardAttachment {
  id         String   @id @default(uuid())
  cardId     String   @map("card_id")
  card       Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  name       String
  url        String
  type       String // "link", "file", "work_item"
  mimeType   String?  @map("mime_type")
  fileSize   Int?     @map("file_size")
  uploadedBy String?  @map("uploaded_by") // User ID
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([cardId])
  @@map("card_attachments")
}

// Custom fields for cards
model CardCustomField {
  id        String   @id @default(uuid())
  cardId    String   @map("card_id")
  card      Card     @relation(fields: [cardId], references: [id], onDelete: Cascade)
  name      String
  value     String   @db.Text
  fieldType String   @default("text") @map("field_type") // "text", "number", "date", "dropdown", "checkbox"
  position  Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([cardId])
  @@map("card_custom_fields")
}

// ============================================
// BELT SYSTEM MODELS
// ============================================

model Belt {
  id       String   @id @default(uuid())
  name     String // e.g., "Sports Championship Belt"
  type     BeltType
  category String? // For CATEGORY belts (SPORTS, POLITICS, etc.)

  // Current holder
  currentHolderId String? @map("current_holder_id")
  currentHolder   User?   @relation("BeltHolder", fields: [currentHolderId], references: [id])

  // Status tracking
  status         BeltStatus @default(VACANT)
  acquiredAt     DateTime?  @map("acquired_at") // When current holder got it
  lastDefendedAt DateTime?  @map("last_defended_at")
  nextDefenseDue DateTime?  @map("next_defense_due") // Mandatory defense date
  inactiveAt     DateTime?  @map("inactive_at") // When it becomes inactive

  // Defense tracking
  timesDefended      Int @default(0) @map("times_defended")
  successfulDefenses Int @default(0) @map("successful_defenses")
  totalDaysHeld      Int @default(0) @map("total_days_held") // Cumulative across all holders

  // Grace period (first 30 days protection)
  gracePeriodEnds DateTime? @map("grace_period_ends")
  isFirstHolder   Boolean   @default(false) @map("is_first_holder")

  // Staking (when belt is at risk)
  isStaked             Boolean     @default(false) @map("is_staked")
  stakedInDebateId     String?     @unique @map("staked_in_debate_id")
  stakedInDebate       Debate?     @relation("BeltStakedDebate", fields: [stakedInDebateId], references: [id])
  stakedInTournamentId String?     @map("staked_in_tournament_id")
  stakedInTournament   Tournament? @relation("BeltStakedTournament", fields: [stakedInTournamentId], references: [id])

  // Tournament-specific belt
  tournamentId String?     @unique @map("tournament_id")
  tournament   Tournament? @relation("TournamentBelt", fields: [tournamentId], references: [id])

  // Belt design/customization
  designImageUrl String? @map("design_image_url")
  designColors   Json?   @map("design_colors") // { primary: "#FF0000", secondary: "#0000FF" }
  sponsorId      String? @map("sponsor_id") // For sponsored belts
  sponsorName    String? @map("sponsor_name")
  sponsorLogoUrl String? @map("sponsor_logo_url")

  // Coin value
  coinValue    Int @default(0) @map("coin_value") // Current market value
  creationCost Int @default(0) @map("creation_cost") // Coins paid to create

  // Admin controls
  isActive   Boolean @default(true) @map("is_active") // Can be deactivated by admin
  adminNotes String? @map("admin_notes")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  history    BeltHistory[]
  challenges BeltChallenge[]
  coinTransactions CoinTransaction[] @relation("CoinTransactionBelt")

  @@index([currentHolderId])
  @@index([type])
  @@index([category])
  @@index([status])
  @@index([tournamentId])
  @@index([stakedInDebateId])
  @@index([stakedInTournamentId])
  @@map("belts")
}

model BeltHistory {
  id     String @id @default(uuid())
  beltId String @map("belt_id")
  belt   Belt   @relation(fields: [beltId], references: [id], onDelete: Cascade)

  // Transfer details
  fromUserId String? @map("from_user_id")
  fromUser   User?   @relation("BeltHistoryFrom", fields: [fromUserId], references: [id])
  toUserId   String? @map("to_user_id")
  toUser     User?   @relation("BeltHistoryTo", fields: [toUserId], references: [id])

  // Transfer context
  reason       BeltTransferReason
  debateId     String?            @map("debate_id")
  debate       Debate?            @relation("BeltHistoryDebate", fields: [debateId], references: [id])
  tournamentId String?            @map("tournament_id")
  tournament   Tournament?        @relation("BeltHistoryTournament", fields: [tournamentId], references: [id])

  // Stats at time of transfer
  daysHeld     Int @map("days_held")
  defensesWon  Int @map("defenses_won")
  defensesLost Int @map("defenses_lost")

  // Admin notes (if manually transferred)
  adminNotes    String? @map("admin_notes")
  transferredBy String? @map("transferred_by") // Admin user ID if manual transfer

  // Timestamps
  transferredAt DateTime @default(now()) @map("transferred_at")

  @@index([beltId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([debateId])
  @@index([tournamentId])
  @@map("belt_history")
}

model BeltChallenge {
  id     String @id @default(uuid())
  beltId String @map("belt_id")
  belt   Belt   @relation(fields: [beltId], references: [id], onDelete: Cascade)

  // Participants
  challengerId String @map("challenger_id")
  challenger   User   @relation("BeltChallenger", fields: [challengerId], references: [id])
  beltHolderId String @map("belt_holder_id")
  beltHolder   User   @relation("BeltHolderChallenge", fields: [beltHolderId], references: [id])

  // Challenge details
  status     ChallengeStatus @default(PENDING)
  entryFee   Int             @default(0) @map("entry_fee") // Coins challenger pays
  coinReward Int             @default(0) @map("coin_reward") // Coins winner gets
  usesFreeChallenge Boolean  @default(false) @map("uses_free_challenge") // True if this challenge uses a free weekly challenge

  // Debate configuration (set by challenger)
  debateTopic          String?  @map("debate_topic") // Topic challenger wants to debate
  debateDescription    String?  @map("debate_description") // Optional description
  debateCategory       String?  @map("debate_category") // Category selected
  debateTotalRounds    Int?     @map("debate_total_rounds") // Number of rounds
  debateRoundDuration  Int?     @map("debate_round_duration") // Duration per round (milliseconds)
  debateSpeedMode      Boolean? @map("debate_speed_mode") // Speed mode enabled
  debateAllowCopyPaste Boolean? @map("debate_allow_copy_paste") // Allow copy/paste
  debateChallengerPosition String? @map("debate_challenger_position") // 'FOR' or 'AGAINST'

  // Response tracking
  response     ChallengeStatus? // ACCEPTED, DECLINED
  respondedAt  DateTime?        @map("responded_at")
  declineCount Int              @default(0) @map("decline_count") // Track declines for mandatory

  // Debate created from challenge
  debateId String? @unique @map("debate_id")
  debate   Debate? @relation("BeltChallengeDebate", fields: [debateId], references: [id])

  // ELO matching (anti-abuse)
  challengerElo Int @map("challenger_elo")
  holderElo     Int @map("holder_elo")
  eloDifference Int @map("elo_difference") // Absolute difference

  // Expiration
  expiresAt DateTime @map("expires_at") // Challenge expires if not responded
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Coin transactions
  coinTransactions CoinTransaction[] @relation("CoinTransactionChallenge")

  @@index([beltId])
  @@index([challengerId])
  @@index([beltHolderId])
  @@index([status])
  @@index([debateId])
  @@map("belt_challenges")
}

model BeltSettings {
  id String @id @default(uuid())

  // Belt type this applies to
  beltType BeltType @unique @map("belt_type")

  // Defense periods (in days)
  defensePeriodDays    Int @default(30) @map("defense_period_days")
  inactivityDays       Int @default(30) @map("inactivity_days")
  mandatoryDefenseDays Int @default(60) @map("mandatory_defense_days")
  gracePeriodDays      Int @default(30) @map("grace_period_days")

  // Challenge rules
  maxDeclines           Int @default(2) @map("max_declines")
  challengeCooldownDays Int @default(7) @map("challenge_cooldown_days")
  challengeExpiryDays   Int @default(3) @map("challenge_expiry_days")

  // ELO matching (anti-abuse)
  eloRange                 Int   @default(200) @map("elo_range") // ±ELO points allowed
  activityRequirementDays  Int   @default(30) @map("activity_requirement_days")
  winStreakBonusMultiplier Float @default(1.2) @map("win_streak_bonus_multiplier") // Can challenge higher ELO

  // Coin economics
  entryFeeBase            Int   @default(100) @map("entry_fee_base")
  entryFeeMultiplier      Float @default(1.0) @map("entry_fee_multiplier") // Based on belt value
  winnerRewardPercent     Int   @default(60) @map("winner_reward_percent")
  loserConsolationPercent Int   @default(30) @map("loser_consolation_percent")
  platformFeePercent      Int   @default(10) @map("platform_fee_percent")

  // Tournament belt creation costs
  tournamentBeltCostSmall  Int @default(500) @map("tournament_belt_cost_small") // 8 players
  tournamentBeltCostMedium Int @default(1000) @map("tournament_belt_cost_medium") // 16 players
  tournamentBeltCostLarge  Int @default(2000) @map("tournament_belt_cost_large") // 32+ players

  // Inactive belt rules
  inactiveCompetitorCount Int @default(2) @map("inactive_competitor_count") // Top N can compete
  inactiveAcceptDays      Int @default(7) @map("inactive_accept_days") // Days to accept challenge

  // Timestamps
  updatedAt DateTime @updatedAt @map("updated_at")
  updatedBy String?  @map("updated_by") // Admin user ID

  @@map("belt_settings")
}

// ============================================
// COIN SYSTEM
// ============================================

enum CoinTransactionType {
  BELT_CHALLENGE_ENTRY    // Entry fee for belt challenge
  BELT_CHALLENGE_REWARD    // Reward for winning belt challenge
  BELT_CHALLENGE_CONSOLATION // Consolation for losing belt challenge
  BELT_TOURNAMENT_CREATION // Cost to create tournament belt
  BELT_TOURNAMENT_REWARD   // Reward for winning tournament
  ADMIN_GRANT             // Admin grants coins
  ADMIN_DEDUCT            // Admin deducts coins
  REFUND                  // Refund for cancelled challenge
  PLATFORM_FEE            // Platform fee (goes to platform account)
  COIN_PURCHASE           // User purchased coins with real money
  COIN_PURCHASE_REFUND    // Refund for coin purchase
}

enum CoinTransactionStatus {
  PENDING   // Transaction pending
  COMPLETED // Transaction completed
  FAILED    // Transaction failed
  REFUNDED  // Transaction refunded
}

model CoinTransaction {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  user      User     @relation("CoinTransactionUser", fields: [userId], references: [id], onDelete: Cascade)

  // Transaction details
  type      CoinTransactionType @map("type")
  status    CoinTransactionStatus @default(COMPLETED) @map("status")
  amount    Int      // Positive for credits, negative for debits
  balanceAfter Int   @map("balance_after") // User's balance after this transaction

  // Related entities (optional)
  beltChallengeId String? @map("belt_challenge_id")
  beltChallenge   BeltChallenge? @relation("CoinTransactionChallenge", fields: [beltChallengeId], references: [id])
  beltId          String? @map("belt_id")
  belt            Belt?   @relation("CoinTransactionBelt", fields: [beltId], references: [id])
  tournamentId    String? @map("tournament_id")
  debateId        String? @map("debate_id")

  // Metadata
  description String? // Human-readable description
  metadata    Json?   // Additional data (e.g., platform fee breakdown)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([beltChallengeId])
  @@map("coin_transactions")
}
